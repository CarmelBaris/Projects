---
title: "Lab Task 6"
author: "Group 6"
date: Sys.Date()
output:
  html_document:
    code_folding: show
editor_options: 
  markdown: 
    wrap: sentence
---

Group members:

- Shawn Yakir , 315714980,  shawn.yakir@mail.huji.ac.il
- Sarah Levitz, 324673623, sarah.levitz@mail.huji.ac.il
- Carmel Baris, 318455276, carmel.baris@mail.huji.ac.il 

### Clean the environment
```{r clean}
rm(list = ls())
```

### Libraries used

```{r libraries}
library('splines')
```


### Paths
```{r paths}
dir_name = "~/Carmel/RProjects/Lab_Benjamini/data/"
#dir_name = "/Users/alevi/Downloads/"
#dir_name = "\\Users\\shawn\\Desktop\\"
```


### Helper functions
```{r helpers}
helpers_file = file.path(dir_name, "help_funcs.R")
source(helpers_file)
helpers = list(loadRData = loadRData, binReads = binReads)
```


### Data
```{r dat}
# Create data file
# source("~/Carmel/RProjects/Lab_Benjamini/data/data_prep.R", echo=TRUE)

load(sprintf("%s/reads_100_A1.rda",path))
load(sprintf("%s/reads_100_B1.rda",path))
load(sprintf("%s/GC_100.rda",path))

chr1t_mat = matrix(reads_100_A1, nr = 50)

# Load data file
reads100_A2 = file.path(dir_name, "reads_100_A2.rda")
reads100_B2 = file.path(dir_name, "reads_100_B2.rda")
reads_gc_20K = helpers$loadRData(reads_file_20K)
GC_20K = reads_gc_20K$GC_20K
reads_20K = reads_gc_20K$reads_20K
```


## Introduction 

This week we began to estimate the number of genomic copies, for a given bin. \n
Our original assumption is that this estimate should be proportional to the coverage, i.e. the number of reads in that bin. \n
So far we have learned that the distribution of $Y_k$, the coverage of bin $K$, depends on the GC content in that bin: $Y_K \sim f(GC_K) + \mathcal{E}_K$. \n
The estimated (predicted) coverage in bin $K$ is given by the following formula: $\hat{Y}_K \sim \hat{f}(GC_K) \ \cdot \ \eta$

is equivalent to the following conditional distribution: $\hat{ùîº}\big[ Y_K|X_K=x_k \big]$. We estimated this distribution using splines regression: $\hat{f}(GC)_K = ùîº[Y_K | X_j \in Bin_K]$



## Fitting bspline regression
```{r fit}
create_est_f = function(X, Y, degree, knots) {
  lknot <- min(X)
  rknot <- max(X)
  lm(Y ~ bs(X, degree = degree, knots = knots, Boundary.knots = c(lknot, rknot)))
}

```


## Q1. Estimating Number of copies 

$$\hat{a}_K = \frac{Y_K}{\hat{f}(GC_K)} \cdot \frac{1}{\mathcal{E}_K}$$

```{r copies}

estimate_num_copies <- function(Y, X, Yhat, varNoise) {
  copies_est <- Y / Yhat
  
  # Apply noise if varNoise is provided
  if (!is.null(varNoise) && varNoise > 0) {
    noise = exp(rnorm(length(Y), mean = 0, sd = sqrt(varNoise)))
    copies_est = copies_est / noise
  }
  
  return(copies_est)
}

```


## Q2.a. Estimating for Specific Region

```{r wet_run}
# Select an area of 1000 consecutive cells
start_idx = 2000  # You can choose any starting index
end_idx = start_idx + 999
selected_GC_20K = GC_20K[start_idx:end_idx]
selected_reads_20K = reads_20K[start_idx:end_idx]

myknots = c(0.415, 0.45, 0.54)

est_f_select = create_est_f(X = selected_GC_20K, Y = selected_reads_20K, degree = 3, knots = myknots)
pred_reads_20K = est_f_select$fitted.values
tiny_v = 0.0001

est_a = estimate_num_copies(Y=selected_reads_20K, X=selected_GC_20K, Yhat=pred_reads_20K, varNoise=tiny_v)
summary(est_a)

# Show the marginal distribution
hist(est_a, main = "Marginal Distribution of Estimated Num of Copies", xlab = "Number of Copies (Est.)")

# Show the genome-wide distribution
plot(est_a, main = "Spatial Distribution of Estimated Num of Copies", 
     xlab = "Chromosomal Index", ylab = "Number of Copies (Est.)",
     ylim = c(0,2), col=rgb(0,0,0,0.75))


# Color outliers in genome-wide distribution
upr_lim = 1.5
lwr_lim = 0.5
suspected = (est_a > upr_lim | est_a < lwr_lim)
abline(h=c(lwr_lim,upr_lim), lwd=1.3, lty=44, col="indianred2")
abline(h=1, lwd=2.5, col="royalblue")

```

## Q2.b. Measuring the Quality of the Estimator

We will compare two estimations, each with a different estimated sample variance of the errors.

```{r}

cat("Variance of noise/error:", sprintf("%.0004f", tiny_v), "\n")
cat("Avg num of copies (est):", round(mean(est_a),4), "\n")
mad_1 = mean(abs(est_a - round(mean(est_a),4)))
cat("Mean Absolute Deviation:", round(mad_1,4), "\n")

cat("\n")

small_v = 0.2
est_a0 = estimate_num_copies(Y=selected_reads_20K, X=selected_GC_20K, Yhat=pred_reads_20K, varNoise=small_v)

cat("Variance of noise/error:", sprintf("%.3f", small_v), "\n")
cat("Avg num of copies (est):", round(mean(est_a0),3), "\n")
mad1 = mean(abs(est_a0 - round(mean(est_a0),4)))
cat("Mean Absolute Deviation:", round(mad1,3), "\n")


```

## Q3. Evaluating the Quality of the Estimator
...

```{r}
estimate_v = function(Y, GC, Yhat) {
  
  # Calculate ratio
  ratio = Y / Yhat
  
  # Remove infinite and zero values
  ratio = ratio[is.finite(ratio) & ratio > 0]
  
  # Estimate v as the sample variance of the log of this ratio
  v_estimate = var(log(ratio))
  return(v_estimate)
}

est_f = create_est_f(X = GC_20K, Y = reads_20K, degree = 3, knots = myknots)
pred_reads_20K = est_f$fitted.values

est_v = estimate_v(reads_20K, GC_20K, pred_reads_20K)
print(round(est_v,2))

```


## Conclusions
* The estimator generally performs well with most estimated copy numbers centered around the expected value of 1.
* There is moderate noise in the data, and the estimator's performance degrades as noise increases.
* Outliers and regions with significant deviations from the expected number of copies need further investigation to understand if they are due to biological variations or noise.
* Fine-tuning the model parameters is essential for improving the estimator's accuracy and robustness.

