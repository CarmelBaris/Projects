---
title: "Lab Task __"
author: "Group 6"
date: Sys.Date()
output:
  html_document:
    code_folding: show
editor_options: 
  markdown: 
    wrap: sentence
---

Group members:

- Shawn Yakir , 315714980, shawnyakir@gmail.com
- Sarah Levitz, 324673623, sarah.levitz@mail.huji.ac.il
- Carmel Baris, 318455276, carmel.baris@mail.huji.ac.il 


# Libraries

```{r library}
library(segmented)
library(data.table)

```

# Setting up environment & paths
```{r setup}
## ------------------------------------------------
## ---- DEPENDENCIES AKA FILES REQUIRED
## Make sure that all files are in the current working directory:
## 1. chr1_bases.rda
## 2. TCGA-13-0723-01A_lib2_all_chr1.forward
## 3. helpers_file
## 
## Note that in this lecture we'll create and save a new file:
## 4. reads_gc_5K.rda


## ------------------------------------------------
## ---- CLEAN ENVIRONMENT
rm(list = ls())


## ---- SET WORKING DIRECTORY
dir_name = "C:/Users/user/Documents/Carmel/Projects/HUJI/Archive_HUJI/data-analysis-genomics/data/"
# dir_name = "/Users/alevi/Downloads/"
# setwd(dir_name)
# getwd() # validate


## ------------------------------------------------
## ---- LOAD HELPER FUNCTIONS
helpers_file = file.path(dir_name, "help_funcs.R")
source(helpers_file)
```

# Loading data files 

```{r warning=FALSE}

## ------------------------------------------------
## ---- LOAD FILE OF NUCLEO_BASES (A,T,C,G)
bases_file = file.path(dir_name, "chr1_line.rda")
chr1_bases = loadRData(bases_file) # like Lecture1


## ------------------------------------------------
## ---- LOAD FILE OF READS LOCATIONS (THAT START A FRAGMENT)
  
reads_file_all = file.path(dir_name,"TCGA-13-0723-01A_lib2_all_chr1.forward")
chr1_reads = data.table::fread(reads_file_all) #like Lecture2
colnames(chr1_reads) = c("Chrom","Loc","FragLen")   


```


# Preprocessing data 

```{r, setup, include=FALSE}

## chunk should not have eval = FALSE!!
## o/w it messes up GC_5K

nreads = nrow(chr1_reads)
myLocations = as.numeric(chr1_reads$Loc)
last_read = myLocations[nreads]

binsize = 5000

## ------------------------------------------------
## ---- BINNING NUCLEO_BASES DATA
##
# per bin, count occurrences of each letter
bases_5K = binBases(chr1_bases, last_read, binsize) 

# per bin, sum occurrence counts of C & G only (GC content)
GC_5K <<- bases_5K[, 3] + bases_5K[, 4] 

# convert GC_5K into percentages
if(any(GC_5K>1)){ # This makes sure I don't repeat the command
  GC_5K = GC_5K / binsize
}

## ------------------------------------------------
## ---- BINNING READS COVERAGE DATA

# per bin, calculate reads coverage 
reads_5K = binReads(myLocations,binsize,last_read)
save(reads_5K, GC_5K,file = file.path(dir_path=dir_name,"reads_gc_5K.rda"))


## ------------------------------------------------
## ---- CLEARING UP ENV

gc()  # garbage collection
print("__________________")
rm("chr1_bases","chr1_reads") # remove from memory
ls()  # list objects in the environment
print("__________________")
gc()

# load data
reads_file_5K = file.path(dir_name, "reads_gc_5K.rda")
reads_gc_5K = loadRData(reads_file_5K)
# access using `$`:
#   GC_5K = reads_gc_5K$GC_5K
#   reads_5K = reads_gc_5K$reads_5K


```



# Remove outliers

```{r}
# Function to remove outliers based on IQR for paired data
remove_outliers_paired <- function(x, y) {
  q1_x <- quantile(x, 0.25)
  q3_x <- quantile(x, 0.75)
  iqr_x <- q3_x - q1_x
  lower_bound_x <- q1_x - 1.5 * iqr_x
  upper_bound_x <- q3_x + 1.5 * iqr_x

  q1_y <- quantile(y, 0.25)
  q3_y <- quantile(y, 0.75)
  iqr_y <- q3_y - q1_y
  lower_bound_y <- q1_y - 1.5 * iqr_y
  upper_bound_y <- q3_y + 1.5 * iqr_y

  mask <- (x > lower_bound_x & x < upper_bound_x) & (y > lower_bound_y & y < upper_bound_y)
  return(list(x = x[mask], y = y[mask]))
}

# Remove outliers from reads and GC content data
cleaned_data <- remove_outliers_paired(GC_5K, reads_5K)
GC_5K_clean <- cleaned_data$x
reads_5K_clean <- cleaned_data$y

```

## Reestimate without small_GC outliers


```{r}
reg_2 = lm(reads_5K~GC_5K,subset = !small_GCs)

plot(GC_5K,reads_5K,ylim = c(0,500),cex = 0.5)
# In a-b line, intercept is a and slope is b

reg1_a = reg_1$coefficients[1]
reg1_b = reg_1$coefficients[2]
reg2_a = reg_2$coefficients[1]
reg2_b = reg_2$coefficients[2]


abline(a=reg1_a,b=reg1_b,col = 4, lw=3)
text(mean(GC_5K),(reg1_b*max(GC_5K)/2+reg1_a),"reg_1",srt=reg1_b*180,pos=1, col=4)

abline(a=reg2_a,b=reg2_b,col = 2, lw=3)
text(mean(GC_5K),(reg2_b*max(GC_5K)/2+reg2_a+15),"reg_2",srt=reg2_b*150,pos=3, col=2)

```

# Question 1: Polynomial regression in pieces


```{r pw_regression}
# Fit piecewise polynomial regression model
initial_model <- lm(reads_5K_clean ~ GC_5K_clean)
seg_model <- segmented(initial_model, seg.Z = ~GC_5K_clean, npsi = 2)

# Extract the breakpoints from the segmented model
breakpoints <- seg_model$psi[, "Est."]
knot1 = breakpoints[[1]]
knot2 = breakpoints[[2]]

# Plot results
plot(GC_5K_clean, reads_5K_clean, pch = 16, cex = 0.5, col = rgb(0,0,0,0.5), 
     xlab = "GC Content (cleaned)", ylab = "Read Counts (cleaned)",
     main = "Piecewise Polynomial Regression")
plot(seg_model, add = TRUE, col = rgb(1,0,0.5,1))

# Plot knots
abline(v=c(knot1,knot2),lt=2, col = rgb(1,0,0.5,0.25), lwd = 1.5)


```

## Count per region

```{r cnt_pw}

# creating a group of `knots`
grp = 1+(GC_5K>knot1)+(GC_5K>knot2)

# count number of observations per segment
knitr::kable(table(grp), col.names = c("Up to knot "," #Dots"))
```

# Question 2: Plotting residuals

Assumed linear model: 
$$ Y_k = \beta_1 \cdot (GC)_k + \beta_0 + \epsilon_k, \\
s.t. \qquad \Bbb E[\epsilon_k]=0 $$
```{r}
reg_1 = lm(reads_5K_clean~GC_5K_clean)
sum_reg_1 = summary(reg_1)
plot(reg_1) 
```


1. Plotting residuals against the explanatory variable
```{r}

GC_x = reg_1$model$GC_5K_clean
res_reg1 = reg_1$residuals

plot(GC_x, res_reg1, pch = 16, cex = 0.5, col = rgb(0,0,0,0.5), 
     xlab = "GC Content (cleaned)", ylab = "Residuals (Y Hat)",
     main = "Piecewise Polynomial Regression")

```

Discussion: 
- What is the diagonal line? 
- Is this a good fit?

If there are many explanatory variables, we can plot against fitted values
```{r}
plot(reg_1$fitted.values,res_reg1,ylim = c(-500,500),cex = 0.5, col = rgb(0,0,0,0.5))

```

2. Add a regression line to the original plot.

If the line is straight, can simply use the `abline` command
```{r}
plot(GC_5K,reads_5K,ylim = c(0,500), cex = 0.3 )
# In a-b line, intercept is a and slope is b
abline(a=reg_1$coefficients[1],b=reg_1$coefficients[2],col = 4, lw=3)
```

In cases where the line is not straight, we need to use the predict command:

1. Prepare sorted points for the "x" variable. The
data structure needs to be a list / data-frame with the correct variable name. 

```{r}
#We'll use regular intervals so the line would come out nicely
predict_data = data.frame(GC_5K = seq(0, 0.7, 0.01))
```

2. Use predict(model, predict_data) to get predictions. 

```{r}
predict_data$yhat = predict(reg_1, predict_data)
```

```{r}
plot(GC_5K,reads_5K,ylim = c(0,500), cex = 0.3 )

# lines only works well if x variable is sorted. 
lines(predict_data$GC_5K, predict_data$yhat, col=4, lw = 3)
```



3. Measure quantitatively using the residuals

Root mean squared error: 
$$rmse(\hat{Y}, Y) = \sqrt{\frac{1}{K}\sum_k (Y_k-\hat{Y}_k)^2} = \sqrt{\frac{1}{K}\sum_k r_k^2}$$

```{r}
# Can use this to estimate SD or MSE
rmse = sqrt(mean(res_reg1^2) )
print(rmse)
```

But this may be strongly affected by outliers. What are more robust measures? 



# The meaning of confidence intervals for the wrong model

Lets' compute approximate CIs for the parameters
```{r}
plot(GC_5K,reads_5K,ylim = c(0,500),cex = 0.5, col = rgb(0,0,0,0.5))

sum_reg_2 = summary(reg_2)
# also draw the +-2 SD intervals for the mean
lower_bd_a = sum_reg_2$coefficients[1,1]-2*sum_reg_2$coefficients[1,2]
upper_bd_a = sum_reg_2$coefficients[1,1]+2*sum_reg_2$coefficients[1,2]

lower_bd_b = sum_reg_2$coefficients[2,1]-2*sum_reg_2$coefficients[2,2]
upper_bd_b = sum_reg_2$coefficients[2,1]+2*sum_reg_2$coefficients[2,2]
abline(a=lower_bd_a,b=lower_bd_b,col = 4, lw=3,lt=2)
abline(a=upper_bd_a,b=upper_bd_b,col = 4, lw=3,lt=2)
```

A better interval uses also the covariance between the parameters. 

```{r}

plot(GC_5K,reads_5K,ylim = c(0,500),cex = 0.5, col = rgb(0,0,0,0.5))
conf_band = predict(reg_2, list(GC_5K = (0:4000)/5000), interval="confidence") 
lines((0:4000)/5000, conf_band[,2],col = 4,lt=3,lw=3)
lines((0:4000)/5000, conf_band[,3],col = 4,lt=3,lw=3)
```

But this is obviously wrong !! 

Reminder:

\[ b_1 = ((X'X)^{-1} X'Y)_{2},  X = (1,GC) \]

Then 
\[b_1 = \frac{cov(gc, coverage)}{var(gc)} \]

and is an estimator for 
\[\beta_1 = \frac{Cov(GC, Coverage)}{Var(GC)}.\]




