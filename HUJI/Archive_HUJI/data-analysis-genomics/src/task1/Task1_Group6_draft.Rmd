---
title: "Task1_Group6"
date: "May 2024"
output:
  html_document:
    code_folding: hide
editor_options: 
  markdown: 
    wrap: sentence
---

## A. Load & Prep Data

```{r}
######## LOAD DATA

## step 0: download rda file from moodle 
## group A gets bases 10M to 30M from chromosome1

## step 1: update directory, do NOT end with slash '/'
dir_name = "~/Carmel/RProjects/Lab_Benjamini"
# setwd(dir_name) #set current directory to path of RDA file
# print(getwd()) #verify change of directory

## step 2: concatenate full path of RDA file
chr1_str_path = sprintf("%s/%s", dir_name, "chr1_str_10M_30M.rda") 

## step 3: load str object to env
load(file = chr1_str_path) #large file so be patient
```

```{r}

######## PRE-PROCESS DATA

## step 4: split 'chr1_str_10M_30M' to a vector of  individual characters
chr1_single = unlist(strsplit(chr1_str_10M_30M, split = "")) #total of 20M bases
chr1_vector = factor(chr1_single, c("A","T","C","G")) #each letter is assigned a number

```


## B. Count Occurrences of Every Nucleobase

```{r updated_func}
subSnippet <- function(start_indx=1, cell_size=1000){
  #' Retrieves a subsection of Chromosome 1 from reference genome.
  #' Calculates number of occurrences for each molecular base (A, T, C, G). 
  #' Nucleobases that their decoding is not certain appear in lowercase.
  #' Unknown nucleobases appear as N.
  #' Utilizes factor() to changes each label (e.g. "A") into a number (1).
  #'
  #' @param start_indx location of first base in region of interest
  #' @param cell_size number of nucleobases included in analysis region

  beg_region = start_indx
  end_region = beg_region + cell_size - 1
#  chr1_list = unlist(strsplit(chr1_str_10M_30M, split = ""))
  chr1_snippet = chr1_vector[beg_region:end_region]
  # return(chr1_snippet)
  # *****should chr1_single be returned or not? consult sarah
  return(list(occurrences_table = table(chr1_snippet),
              chr1_snippet = chr1_snippet))
}
```

Note: Default starting index (1) and cell size (1K nucleobases) can be overriden.

```{r sanity_subsnippet_func, echo=FALSE}
# result_sub = subSnippet(start_indx=20000001-10, cell_size=10)
# result_sub = subSnippet(cell_size=20000001)
result_sub = subSnippet()
counts = result_sub$occurrences_table
chr1_single = result_sub$chr1_single
chr1_snippet = result_sub$chr1_snippet
head(chr1_snippet, 100)
# print(list(chr1_single[1:10], length(chr1_single)))
# print(list(chr1_vector[1:10], length(chr1_vector)))
cat("\n", "Total nucleobases in scope:", sum(counts), "\n\n") #like cell size
print(counts)
```



We can exclude "N" as a level, so it is treated as a missing value.
Adding the missing values makes this object larger.
We can access where the missing values are using the "is.na()" function

```{r sanity_missing_vals}
## consult sarah: even including N it is not full size... reason is unclear
anyNA(chr1_vector) # returns T if any entries are empty/missing; otherwise, F
sum(is.na(chr1_vector)) # returns 0 if no values are missing
format(object.size(chr1_vector), units = "Mb")
format(object.size(chr1_single), units = "Mb")


```



```{r, echo=FALSE}

# full data includes 20M nucleobases
counts = table(chr1_vector, useNA = "ifany")
counts_in_millions = counts / 1e6 # s.t. one million appears as 1
formatted_table <- data.frame(
  CountInMillions = format(counts_in_millions, digits = 2, nsmall = 2, scientific = FALSE)
)
print(formatted_table)

```




```{r}
# ?plot.table
# ?plot.default
plot(counts_in_millions, 
     xlab = "NucleoBase", ylab = "Count (Millions)", main = "Chromosome 1", 
     lwd = 10, frame.plot=T)

nas = is.na(chr1_vector)
abline(h=counts_in_millions[["C"]][1]) #straight line at height of C, rounded down
```

## Looking at the 4-letter sequence?

```{r}

N = length(chr1_vector)
izug = seq(from = 1,to=N,by = 2)
zug = seq(2,N,2)
counts2_z = table(chr1_vector[izug],chr1_vector[zug])
counts2 = table(chr1_vector[1:(N-1)],chr1_vector[2:N])

mosaicplot(counts2_z)
mosaicplot(counts2)

# After Normalization and round
round(counts2_z/sum(counts2_z),3)


```

We want to study letter prevalence at each region.
How do we look at it?

```{r}
stam_range = 5000000+(1:100)
# stam_range = 5000000+(1:1000)
plot(stam_range,chr1_vector[stam_range]=="A")
```

It's hard to see anything...

One way, to bin it:

```{r}
N = length(chr1_vector)
bin_size = 1000
n_bins = ceiling(N/bin_size)
A_count = numeric(N/bin_size)
T_count = numeric(N/bin_size)
C_count = numeric(N/bin_size)
G_count = numeric(N/bin_size)
for (i in 1:n_bins){
  start_bin = 1+ (i-1)*bin_size
  end_bin = i*bin_size
  A_count[i] = sum(chr1_vector[start_bin:end_bin] == "A")
  T_count[i] = sum(chr1_vector[start_bin:end_bin] == "T")
  C_count[i] = sum(chr1_vector[start_bin:end_bin] == "C")
  G_count[i] = sum(chr1_vector[start_bin:end_bin] == "G")
}
```

And analyze this line

```{r}
n = length(chr1_vector)
for (i in seq(0,n,by=1000)){
  start_bin = 1+ (i-1)*bin_size
  end_bin = i*bin_size
  A_count[i] = sum(chr1_vector[start_bin:end_bin] == "A")
}
```

```{r}
hist(A_count)
hist(T_count)
hist(C_count)
hist(G_count)
```


```{r}
rug(A_count)
plot(density(A_count,na.rm=T))
rug(A_count)

length(A_count)
summary(A_count)
boxplot(A_count,horizontal=TRUE)
# Is it similar to an 0.25 Binomial?
# You can check...

# Is it similar to a normal?
norm_A = (A_count - mean(A_count,na.rm=TRUE))/sd(A_count,na.rm=TRUE)
below05 = (norm_A < qnorm(0.05))
mean(below05,na.rm=T)
above95 = (norm_A > qnorm(0.95))
mean(above95,na.rm=T)

```

Align with location...

```{r}
plot(A_count)

plot(A_count[2000:n_bins],pch =20, cex = 0.5)
plot((1:n_bins)*bin_size,A_count,pch =20, cex = 0.3)
plot((1:n_bins)*bin_size,A_count,pch =20, cex = 0.5, xlab = "Location")
plot((2000:n_bins)*bin_size,A_count[2000:n_bins]/bin_size,pch =20, cex = 0.5, xlab = "Location")
abline(h = 0.25)
# Make sure that plot is sufficiently wide so that the sequence is easy to see...

```

Rerun for all four letters

```{r}
bin_size = 2000
n_bins = ceiling(N/bin_size)
let_count = matrix(nr = N/bin_size,nc = 5)
letters = c("A","C","G","T")
for (i in 1:n_bins){
  start_bin = 1+ (i-1)*bin_size
  end_bin = i*bin_size
  for (let in 1:4) {
    let_count[i,let] = sum(chr1_vector[start_bin:end_bin] ==letters[let],na.rm=TRUE)
  }
}
plot((1:n_bins)*bin_size,let_count[,4]/bin_size,pch =20, cex = 0.5, xlab = "Location")

# We get a matrix with 4 columns for each of the four base-types, and n_bins rows for each of the bins
```

How can we compare?

Horizontal alignment for the four letters:

```{r}
# Check out examples in plotting.html file
#
# par() adds parameters to the plotting 
# par(mfcol = c(nr,nc)) makes a grid of nr rows of plots and nc columcns of plots. Here, one column and four rows
# par(mar = c(a,b,c,d)) is the margins (shulaim) around each plot 

par(mfcol = c(4,1))
for (i in 1:4){
  plot((1:n_bins)*bin_size,let_count[,4]/bin_size,pch =20, cex = 0.5, xlab = "Location")
}

# So, we change the margins
par(mfcol = c(4,1),mar = c(1,0,0,0))
for (i in 1:4){
  plot((1:n_bins)*bin_size,let_count[,i]/bin_size,pch =20, cex = 0.5, xlab = "Location")
}

```

Or scatter plot between pairs of letters:

```{r}
par(mfcol = c(1,1),mar = c(4,3,3,3))
plot(let_count[,1],let_count[,4])
plot(let_count[,1],let_count[,3])
plot(let_count[,2],let_count[,3])
```

Is there any correlation between neighboring bins?

```{r}
par(mfcol = c(1,1),mar = c(4,3,3,3))
n_bins = nrow(let_count)
plot(let_count[2:n_bins,1],let_count[1:n_bins-1,1])

```
