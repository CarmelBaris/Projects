---
title: "Task2"
date: "27 May 2024"
output:
  html_document:
    code_folding: show
  pdf_document: default
editor_options:
  markdown:
    wrap: sentence
---

Group 6 aka 5A:
 - Shawn Yakir , 315714980, shawnyakir@gmail.com  
 - Sarah Levitz, 324673623, sarah.levitz@mail.huji.ac.il
 - Carmel Baris, 318455276, carmel.baris@mail.huji.ac.il


### Libraries used

```{r libraries, warning=FALSE, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library('ggplot2')
library('data.table')
library('manipulate')
library('tictoc')

```


### Paths and Data


```{r data_A, message=FALSE, warning=FALSE}

# Group A file
reads_file = 'C:/Users/user/Documents/Carmel/Projects/HUJI/Archive_HUJI/data-analysis-genomics/data/TCGA-13-0723-01A_lib2_all_chr1.forward'

# reads_file = "/Users/alevi/Downloads/ATCGA-13-0723-01A_lib2_all_chr1.forward/TCGA-13-0723-01A_lib2_all_chr1.forward"

chr1_reads = fread(reads_file) 
colnames(chr1_reads) = c("Chrom","Loc","FragLen")
```


## Introduction 

This week we analyzed a text-based sequencing data file used in Paired End Sequencing. It stores short reads that were generated using Next Generation Sequencing (NGS). To clarify, in our work 'reads' refer to the first read of a DNA fragment. These fragments differ in the locaiton of their first read, and in their size. \n

We attempted to identify trends in the data. To be specific, our focus was on understanding the marginal and spatial distribution of reads along the chromosome being sequenced. \n


## Q1: getLine function

The function takes two inputs: 1) a vector of chromosomal locations for which we have a collection of first-reads, and 2) a region of interest along the chromosome (start and end points). For the given region, it outputs a vector containing the count of reads mapped to the chromosomal location, relative to the region's starting point. \n


```{r getLine_func, message=FALSE, warning=FALSE}

getLine = function(locations, beg_region, end_region) {
  
  # Initialize the vector to store the counts
  N = end_region - beg_region + 1
  loc_line = numeric(N)
  
  # Loop through the locations and increment the count
  for (loc in locations) {
    
    # Increase count in corresponding index (relative to first read)
    if (loc >= beg_region && loc <= end_region) {
      loc_line[loc - beg_region + 1] = loc_line[loc - beg_region + 1] + 1
    }
  }
  
  return(loc_line)
}
```


Testing the function on 20M bases:

```{r}

locations = chr1_reads$Loc

# Define the beginning and end of the region
beg_region = 1
end_region = 1 + 2e+07

start_time <- proc.time()

reads_20M <- getLine(locations, beg_region, end_region)
end_time <- proc.time()

elapsed_time <- end_time - start_time

# Count non-zero values
non_zero_count <- sum(reads_20M != 0)
print(paste("Function run time:", round(elapsed_time["elapsed"],2), "seconds"))
print(paste("Number of fragments:", round(non_zero_count/1000,2), "K"))

```

## Q2: Marginal Distribution of Single Locations Being Sequenced

The following histogram demonstrates the marginal distribution of the given chromosome by counting the number of fragments that begin in each individual location. \n

```{r hist_locs}

# Part 1: Histogram for individual locations

# read the data and create histogram
read_hist <- hist(reads_20M, breaks = 0:40 - 0.5, plot = FALSE)

# function to format the values
format_labels <- function(x) {
  if (x >= 1e6) {return(paste0(round(x / 1e6, 2), "M"))}
  if (x >= 1e3) {return(paste0(round(x / 1e3, 1), "K"))} 
  else {return(as.character(x))
  }
}

# define y-axis limits
y_lim <- c(0, max(read_hist$counts) * 1.1)

# plot the histogram without y-axis
plot(read_hist, ylim = y_lim, yaxt = "n", 
     main = "Number of Chrom1 Locations Containing X Reads",
     xlab = "Read Count (Per Location)", 
     ylab = "Location Count")

# format y-axis labels
y_ticks <- axTicks(2)
formatted_y_ticks <- sapply(y_ticks, format_labels)
axis(2, at = y_ticks, labels = formatted_y_ticks)

# format histogram labels
formatted_counts <- sapply(read_hist$counts, format_labels)

# add formatted labels to the histogram
text(read_hist$mids,
     read_hist$counts,
     formatted_counts,
     pos = 3, cex = 0.65)
# lines(rpois(reads_20M, mean(reads_20M)))


```

Clearly, the great majority of bins have only 1 read, or no reads at all. \n
```{r}
df <- data.frame(x)

# Histogram with kernel density
ggplot(df, aes(x = x)) + 
  geom_histogram(aes(y = ..density..),
                 colour = 1, fill = "white") +
  geom_density()
```


# Q3: Count Per Aggregated Bin of Reads


```{r message=FALSE, warning=FALSE, include=FALSE}

## Binning reads into 20K bp (incl last_read)

#Preparing vector of read counts in bins of 20K
last_read = as.numeric(nrow(chr1_reads))
N20K = ceiling(last_read/20000)

reads_20K= numeric(N20K)
for (r in 1:nrow(chr1_reads)){
  biN20K = 1+floor((chr1_reads$Loc[r]-1)/20000) 
  reads_20K[biN20K] = reads_20K[biN20K]+1 
}

```

By clustering the data into bins of 10K reads each, we achieve an aggregated view of the marginal distribution. \n

```{r}
# find outliers:
h <- hist(pmin(reads_20K,4000),breaks = 100,plot = FALSE)

# plot the histogram without x-axis
plot(h, xaxt="n",
     main = "Number of Bins Containing X Reads",
     xlab = "Read Count (Per Bin of 10K Bases)", ylab = "Number of Bins")

# format x-axis labels
x_ticks <- axTicks(1)
formatted_x_ticks <- sapply(x_ticks, format_labels)
axis(1, at = x_ticks, labels = formatted_x_ticks)


# add markers of outliers
bottom_cut = 600
top_cut = 2600

lcut_space = 50
lcut_ylim = 40

abline(v=c(bottom_cut,top_cut),col=rgb(1,0,0,1), lw=1.5)
text(x=bottom_cut-lcut_space,y=lcut_ylim, 
     labels="Cutoff of <600",
     bg="transparent",col = "red", cex = 0.7, srt=90,pos=3)
text(x=top_cut-lcut_space,y=lcut_ylim, 
     labels="Cutoff of >2600",
     bg="transparent",col = "red", cex = 0.7, srt=90,pos=3)

```


As before, the majority of bins register a very low number of reads, mostly clustering around zero, with a right-skewed distribution. \n

Yet in the center of the histogram, we now recognize a semi bell-curve distribution. \n

Seeing as the out seen to mask the central distribution, we will exclude them and further analyze the remaining bins. \n

Marked in red are the cutoff values of an average coverage below 200 and over 400 reads per bin of 10K. \n



# Zoomed-In Observation of Curved Distribution
```{r}
# logical vector s.t. TRUE if condition is met (within selected cutoff range)
no_outlier = !is.na(reads_20K) & reads_20K > 600 & reads_20K < 2600

# exclude outliers
h_no_out = hist(reads_20K[no_outlier],breaks=100, plot = FALSE)

# plot the histogram without y-axis (no explicit y-limit this time)
plot(h_no_out, xaxt = "n",
     main = "Number of Bins Containing X Reads (Excl. Outliers)",
     xlab = "Read Count (Per Given Bin)", ylab = "Number of Bins")

# format x-axis labels
x_ticks <- axTicks(1)
formatted_x_ticks <- sapply(x_ticks, format_labels)
axis(1, at = x_ticks, labels = formatted_x_ticks)

# add markers of outliers
light_red=rgb(1,0,0,0.25)
abline(v=c(bottom_cut,top_cut),col=light_red, lw=2.5)
text(x=top_cut-15,
     y=20, 
     labels="Cutoff of <2600",
     bg="transparent",col = light_red, cex = 0.7, srt=90,pos=3)
text(x=bottom_cut-15,
     y=20, 
     labels="Cutoff of >600",
     bg="transparent",col = light_red, cex = 0.7, srt=90,pos=3)

y_stats=as.data.frame(t(summary(h_no_out$counts)))
y_max=y_stats$Freq[[6]]

x_stats=as.data.frame(t(summary(reads_20K[no_outlier])))
x_mean=x_stats$Freq[[4]]

# add marker of mean
m_no_out = mean(reads_20K[no_outlier])
segments(x0=m_no_out,x1=m_no_out,y0=0,y1=y_max-10,col="darkblue",lw=2)
text(x=x_mean, y=y_max-5, 
     labels=paste0("Avg. Count\n",round(m_no_out/1000,2),"K"),
     col = "darkblue", cex = 0.8)



```

By filtering out records of extreme read counts per bin, we recognize what seems to be a double-hump around the center of the bell-curve. \n

This may possibly indicate the existence of two overlapping distributions. \n

# Q4: Fitting a Normal Distribution

```{r}
# Convert vector to a data frame
read_counts_df <- data.frame(
  Count = reads_20M,
  Location = seq(beg_region, end_region)
)

head(read_counts_df)
```
```{r message=FALSE, warning=FALSE}
# Fit a normal distribution to the read counts
mean_read_counts = mean(read_counts_df$Count)
sd_read_counts = sd(read_counts_df$Count)

# Create a histogram of the read counts
p <- ggplot(read_counts_df, aes(x = Count)) +
  geom_histogram(aes(y = ..density..), binwidth = 1, color = "black", fill = "white") +
  stat_function(fun = dnorm, args = list(mean = mean_read_counts, sd = sd_read_counts), color = "purple", size = 1) +
  labs(title = "Histogram of Read Counts with Fitted Normal Distribution",
       x = "Number of Reads",
       y = "Density") +
  theme_minimal()

print(p)

```


The histogram shows that the majority of locations have a very low number of reads, mostly clustering around zero, with a right-skewed distribution.

The fitted normal distribution does not match the histogram well.
The normal distribution is symmetric and bell-shaped, which does not align with the right-skewed nature of the read count distribution.
The histogram's peak is at the beginning (near zero), while the normal distribution's peak is at the mean, leading to a poor fit.
The normal distribution is not suitable for this data due to its right-skewed nature and the heavy concentration of low read counts.



## Short summary

Based on our analysis of the data, it seems that the reads are not distributed normally or uniformly.

