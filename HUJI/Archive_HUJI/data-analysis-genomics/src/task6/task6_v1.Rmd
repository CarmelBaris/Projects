---
title: "Lab Task 6"
author: "Group 6"
date: Sys.Date()
output:
  html_document:
    code_folding: show
editor_options: 
  markdown: 
    wrap: sentence
---

Group members:

- Shawn Yakir , 315714980, shawnyakir@gmail.com
- Sarah Levitz, 324673623, sarah.levitz@mail.huji.ac.il
- Carmel Baris, 318455276, carmel.baris@mail.huji.ac.il 


### Clean the environment
```{r clean}
rm(list = ls())
```

### Libraries used

```{r libraries}
library('splines')
```


### Paths
```{r paths}
dir_name = "~/Carmel/RProjects/Lab_Benjamini/data/"
#dir_name = "/Users/alevi/Downloads/"
#dir_name = "\\Users\\shawn\\Desktop\\"
```


### Helper functions
```{r helpers}
helpers_file = file.path(dir_name, "help_funcs.R")
source(helpers_file)
helpers = list(loadRData = loadRData)
```


### Data
```{r dat}
# Create data file
# source("~/Carmel/RProjects/Lab_Benjamini/data/data_prep.R", echo=TRUE)

# Load data file
reads_file_20K = file.path(dir_name, "reads_gc_20K_cln.rda")
reads_gc_20K = helpers$loadRData(reads_file_20K)
GC_20K = reads_gc_20K$GC_20K
reads_20K = reads_gc_20K$reads_20K
```


## Introduction 

This week we began to estimate the number of genomic copies, for a given bin. \n
Our original assumption is that this estimate should be proportional to the coverage, i.e. the number of reads in that bin. \n
So far we have learned that the distribution of $Y_k$, the coverage of bin $K$, depends on the GC content in that bin: $Y_K \sim f(GC_K) + \mathcal{E}_K$. \n
The estimated (predicted) coverage in bin $K$ is given by the following formula: $\hat{Y}_K \sim \hat{f}(GC_K) \ \cdot \ \eta$

is equivalent to the following conditional distribution: $\hat{E}\big[ Y_K|X_K=x_k \big]$. We estimated this distribution using splines regression: $\hat{f}(GC)_K = E[Y_K | X_j \in Bin_K]$



## FITTING BSPLINE REGRESSION (ALL DATA)
```{r fit}
# Fit the regression models
knots_bs = c(0.415, 0.45, 0.54)
lknot = min(GC_20K)
rknot = max(GC_20K)
est_f = lm(formula = reads_20K ~ bs(GC_20K, degree = 3, 
                                      knots = knots_bs, 
                                      Boundary.knots = c(lknot, rknot)))

```


## Q1: 
$$\hat{a}_K = \frac{Y_K}{\hat{f}(GC_K)}$$
```{r copies}
estimate_v <- function(Y, GC, est_f) {
  expected_reads <- predict(est_f, newdata = data.frame(GC_20K = GC))
  
  # Add a small constant to avoid division by zero or log of zero
  epsilon <- 1e-10
  log_ratio <- log((Y + epsilon) / (expected_reads + epsilon))
  
  # Remove infinite values
  log_ratio <- log_ratio[is.finite(log_ratio)]
  
  v_estimate <- var(log_ratio, na.rm = TRUE)
  return(v_estimate)
}


estimate_v_alt <- function(Y, GC, est_f) {
  expected_reads <- predict(est_f, newdata = data.frame(GC_20K = GC))
  
  # Calculate ratio
  ratio <- Y / expected_reads
  
  # Remove infinite and zero values
  ratio <- ratio[is.finite(ratio) & ratio > 0]
  
  # Estimate v as the variance of the log of this ratio
  v_estimate <- var(log(ratio))
  return(v_estimate)
}

# Use the function
est_v <- estimate_v(reads_20K, GC_20K, est_f)
print(est_v)


est_num_copies <- function(Y, GC, f_x, v) {
  n <- length(Y)
  a_estimate <- numeric(n)
  
  f <- function(gc) {
    new_data <- data.frame(GC_20K = gc)
    predict(est_f, newdata = new_data)
  }
  
  for (i in 1:n) {
    lambda_i <- Y[i] / (f(GC[i]) * exp(rnorm(1, 0, sqrt(v))))
    a_estimate[i] <- lambda_i
  }
  
  return(a_estimate)
}

est_num_copies_alt <- function(Y, GC, est_f, v) {
  n <- length(Y)
  a_estimate <- numeric(n)
  
  f <- function(gc) {
    new_data <- data.frame(GC_20K = gc)
    predict(est_f, newdata = new_data)
  }
  
  for (i in 1:n) {
    lambda_i <- Y[i] / (f(GC[i]) * exp(rnorm(1, 0, sqrt(v))))
    # Constrain estimates to a reasonable range
    a_estimate[i] <- min(max(lambda_i, 0), 10)
  }
  
  return(a_estimate)
}

est_v = estimate_v(reads_20K, GC_20K, est_f)
est_v2 = estimate_v_alt(reads_20K, GC_20K, est_f)
est_a = est_num_copies(reads_20K, GC_20K, est_f, 1)
est_a2 = est_num_copies_alt(reads_20K, GC_20K, est_f, 1)
head(est_a)
head(est_a2)
head(est_v)
head(est_v)

```

## Conclusion


