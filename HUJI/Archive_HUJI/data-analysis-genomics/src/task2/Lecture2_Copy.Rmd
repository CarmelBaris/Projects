---
title: "Lecture2"
author: "Yuval Benjamini"
date: "21 May, 2024"
output: html_document
---

```{r libraries, message=FALSE, warning=FALSE}
  library('data.table')
  library('tictoc')
  library('manipulate')

```


Read the file...
fread is a more efficient function for reading large tables from files

```{r}

# Original
reads_file = 'C:/Users/user/Documents/Carmel/Projects/HUJI/Archive_HUJI/data-analysis-genomics/data/TCGA-13-0723-01A_lib2_all_chr1.forward'

# Group A
# reads_file = 'C:/Users/user/Documents/Carmel/Projects/HUJI/Archive_HUJI/data-analysis-genomics/data/TCGA-13-0723-10B_lib2_all_chr1.forward'


chr1_reads = fread(reads_file) 

# adding column names:
colnames(chr1_reads) = c("Chrom","Loc","FragLen")   

head(chr1_reads)
summary(chr1_reads)
```



## Read depth
---------


```{r}
# goes to last entry in data and retrieves its location (loc in chromosome 1)
dat_rows = nrow(chr1_reads)
last_read = chr1_reads[dat_rows,"Loc"] 

# Avg. Read Depth
# total(Reads)/total(Bases)
coverage = dat_rows / last_read

# Avg. Distance Between Reads
# total(Bases)/total(Reads)
avg_dis = 1/coverage # divides full data length by avg

print(c(LastRead=last_read,
        Coverage=coverage,
        AvgDist=avg_dis))

```


### Create read_line

How many reads at each point? 
```{r yuv_1}
beg_region = 1
end_region = 10000000
N = end_region-beg_region+1

# prepare read_line_1 of size N 
read_line_1 = numeric(N)

# tic toc measures how long code takes to run.
tic()
# so that read_line_1[i] is the number of reads beginning at i
for (i in 1:100){
  
  # if a location i appears in dataset, add 1 to value of corresp. index
  read_line_1[i] = sum(chr1_reads$Loc == (i+beg_region-1))
  
}
toc()
# circa 20 seconds

```


So we should make this algorithm more efficient. 
Here is one attempt. 

```{r yuv_2}

# prepare read_line of size N 
beg_region = 1
end_region = 10000000
N = end_region-beg_region+1
read_line = numeric(N)

tic()
first_read = min(which(chr1_reads$Loc >= beg_region)) 
r = first_read

# Use proc.time when the command is not a one line. 
# It measures current time, and can be subtracted out.
tt = proc.time()

while (chr1_reads$Loc[r] <= end_region){
  read_line[chr1_reads$Loc[r]] = read_line[chr1_reads$Loc[r]]+1
  r = r+1
}
toc()
# circa 5-9 seconds

```


Things to remember when trying to be efficient: 
- Always have a slow implementation that you know is correct before making efficient
- Check that this is really what you need to optimize


Rewrite as a function
(this is for you...)
```{r}
getReadLine = function(locations, beg_region, end_region){
  # Assumptions: locations is a sorted vector of beginnings
  # Don't forget - what happens if beg_region is not equal to 1?
  
  # Complete....
  
  return(line)
}
```



plot non-zero histogram

```{r}

rl_empty = read_line[which(is.na(read_line) | read_line <= 0)]
rl_nempty = read_line[which(read_line > 0)]

# mt = length(rl_empty)/N
# nmt = length(rl_nempty)/N
# mt_nmt = mt+nmt
# paste0(100*mt_nmt, "%")

summary(rl_empty)
summary(rl_nempty)

hist.data = hist(rl_nempty, plot=FALSE, breaks = 1:40-0.5)
hist.data2 = hist(rl_nempty, freq = FALSE, breaks = 1:40-0.5)



```

applying log10 to histogram

```{r}
hist.data$counts = log10(1+hist.data$counts)


dev.new(width=4, height=4)
plot(hist.data, ylab='log10(Frequency)')



summary(read_line)

# read_hist = hist(read_line,breaks = 0:20-0  .5)
# create histogram that its scale ranges from -0.5 to 39.5 (in jumps of 1)
read_hist = hist(read_line,breaks = (0:40) - 0.5)
rl_pmin=pmin(read_line,20)
hist(rl_pmin)
text(read_hist$mids,read_hist$counts,read_hist$counts,pos = 3,cex =0.5)
# pos = 1,2,3,4 moves the value a bit to the bottom,left,top,right
#    of the scheduled location. See ?text.

```

```{r}


opar <- options(scipen=100)

read_hist = hist(read_line,breaks = 0:40-0.5,
                 ylim = c(0, 500000))
text(read_hist$mids,
     read_hist$counts,
     read_hist$counts,
     pos = 3,cex =0.5)

par(opar) ## restore original settings 

```

Is the distribution of reads uniform? 
That would lead to a Poisson marginal distribution...

## Binning reads into 30000 bp 

Preparing our read line (i.e. vec of counts in bin of 30K)...
```{r}
last_read = as.numeric(last_read)
N30K = ceiling(last_read/30000)

tic()
reads_30K= numeric(N30K)
for (r in 1:nrow(chr1_reads)){
  # Need to check such dangerous lines...
  biN30K = 1+floor((chr1_reads$Loc[r]-1)/30000) 
  reads_30K[biN30K] = reads_30K[biN30K]+1 
}
toc()

# Check that these are correct
reads_30K[1]
chr1_reads[reads_30K[1]+c(-10:10),]
```

## Identify outliers by looking at marginal distribution
1 dimensional display

```{r}
# most reads are mapped to the value 0 or 1
summary(reads_30K)

# this makes the histogram very marginalized
# can't see anything, most values are plotted to a single bar
hist(reads_30K)

# therefore, we need to control the plot size
# we'll demonstrate using boxplots:
boxplot(reads_30K)

# controlling maximum range of the y-axis
boxplot(reads_30K,ylim = c(0,30000))
boxplot(reads_30K,ylim = c(0,10000))

# rotating the box-plot by 90 degrees
boxplot(reads_30K,ylim = c(0,10000),horizontal = TRUE)

```


## x.zoom in to a limited range of values (no large than cutoff)

```{r}
# cutoff at 10K counts - remove values higher than 10K

# pmin: for each in given vector (arg1), compare to arg2 & choose the minimal
r50K_pmin4K = pmin(reads_30K,4000)
r50K_pmin6K = pmin(reads_30K,6000)
pmin_r50K = pmin(reads_30K,10000)

# verify that indeed the maximum is at 10K
summary(pmin_r50K)
h = hist(pmin_r50K,breaks = 100)
h_pmin6K = hist(r50K_pmin6K,breaks = 100)
h_pmin10k = hist(r50K_pmin4K,breaks = 100)

# find outlier cutoffs:
btm_cut = 20
top_cut = 300
abline(v=c(btm_cut,top_cut),col="red")
no_outlier = reads_30K>btm_cut &reads_30K<top_cut
mean(no_outlier) #proportion of non-outlier

# Estimate density of distribution body
h_no_out = hist(reads_30K[no_outlier],breaks=100)

m_no_outliers =mean(reads_30K[no_outlier])
abline(v=m_no_outliers,col="red",lw=2)
```

For this plot, I will want you to compare to the Gaussian distribution

## This will wait till next class
```{r}
# compute poisson probabilities and compare to obeserved probabilities...
pois_probs = dpois(0:660,m_no_outliers)
# Compare these to the probabilities from the bulk. 
# What does this model imply for the probability of being between X_i in 100:109?
sd(reads_30K[no_outlier],na.rm=TRUE)
```


## Scatter Plots

```{r}
plot(reads_30K)
plot(reads_30K,ylim=c(0,30000)) # cutoff at 30K
plot(reads_30K,ylim=c(0,20000)) # cutoff at 1K

# find only the outlier points (above 8K)
outlier_above = which(reads_30K > 6000)

# color the outliers (in col2=red)
plot(reads_30K,ylim=c(0,10000),col = rgb(0,0,0,0.5)) # lighter hue
points(outlier_above,rep(6000,length(outlier_above)),col=2,cex =0.2)

plot(reads_30K,ylim=c(0,10000),col = rgb(0,0,0,0.5)) # lighter hue
points(outlier_above,rep(6000,length(outlier_above)),col=2,cex =0.6)

plot(reads_30K,ylim=c(0,10000),col = rgb(0,0,0,0.5)) # lighter hue
points(outlier_above,rep(6000,length(outlier_above)),col=2,cex =0.9)

plot(reads_30K,ylim=c(0,10000),col = rgb(0,0,0,0.4), cex=0.7) 
points(outlier_above,rep(6000,length(outlier_above)),col=2,cex =1.1, pch=20)
text(outlier_above, labels=paste(outlier_above, sep=","))
# col controls color, supports rgb(red,green,blue,hue)
# cex controls size of points
```



```{r}
x.zoom=30000:40000

# plot then add a smoothing line that shows trends
plot(x.zoom, reads_5K[x.zoom],ylim = c(0,1000),col = rgb(0,0,0,0.5),cex =0.5)
lines(col=4, lw=3, x=loess.smooth(x.zoom, reads_5K[x.zoom]))

# smoothing line at higher resolution (less smoothing)
plot(x.zoom, reads_5K[x.zoom],ylim=c(0,1000),col = rgb(0,0,0,0.5),cex =0.5)
lines(col=4, lw=3, x=loess.smooth(x.zoom, reads_5K[x.zoom],span = 0.01))
```

```{r}
x.zoom1=10000:20000
x.zoom2=20000:30000
x.zoom3=30000:40000
x.zoom4=1000:4000 #must be within length range of reads_... being plotted

plot(x.zoom1,reads_5K[x.zoom1],ylim=c(0,1000),col = rgb(0,0,0,0.5),cex =0.5)
lines(loess.smooth(x.zoom1,reads_5K[x.zoom1],span = 0.01),col=4,lw=3)

plot(x.zoom2,reads_5K[x.zoom2],ylim=c(0,1000),col = rgb(0,0,0,0.5),cex =0.5)
lines(loess.smooth(x.zoom2,reads_5K[x.zoom2],span = 0.01),col=4,lw=3)

plot(x.zoom3,reads_5K[x.zoom3],ylim=c(0,1000),col = rgb(0,0,0,0.5),cex =0.5)
lines(loess.smooth(x.zoom3,reads_5K[x.zoom3],span = 0.01),col=4,lw=3)

plot(x.zoom4,reads_5K[x.zoom4],ylim=c(0,1000),col = rgb(0,0,0,0.5),cex =0.5)
lines(loess.smooth(x.zoom4,reads_5K[x.zoom4],span = 0.01),col=4,lw=3)


```

```{r}
x.zoom5=3000:8000 #must be within length range of reads_... being plotted
plot(x.zoom5,reads_30K[x.zoom5],ylim=c(0,6000),col = rgb(0,0,0,0.5),cex =0.5)
lines(loess.smooth(x.zoom5,reads_30K[x.zoom5],span = 0.01),col=4,lw=3)

```

Google "R plots with sliders" and find relevant package
Use "manipulate" to explore graph. This doesn't work well in Markdown

```{r,eval = FALSE}
# Define the plotting function
plot_with_abline <- function(x) {
  plot(x + (1:pl), reads_30K[x + (1:pl)], ylim = c(0, 6000), pch = 20, cex = 0.8)
  abline(h = 4000, col = "red", lw = 2)
}

# Use manipulate to add interactivity (run in console)
manipulate(
  plot_with_abline(x),
  x = slider(1, length(reads_30K) - pl + 1, initial = 200)
)
```

