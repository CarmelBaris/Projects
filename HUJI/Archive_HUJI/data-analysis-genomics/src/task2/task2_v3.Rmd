---
title: "Task2"
date: "27 May 2024"
output:
  html_document:
    code_folding: show
  pdf_document: default
editor_options:
  markdown:
    wrap: sentence
---

Group 6 aka 5A:
 - Shawn Yakir , 315714980, shawnyakir@gmail.com  
 - Sarah Levitz, 324673623, sarah.levitz@mail.huji.ac.il
 - Carmel Baris, 318455276, carmel.baris@mail.huji.ac.il


### Libraries used

```{r libraries, warning=FALSE, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library('ggplot2')
library('data.table')
library('manipulate')
library('tictoc')

```


### Paths and Data


```{r data_A, message=FALSE, warning=FALSE}

reads_file = '~/Carmel/RProjects/Lab_Benjamini/data/TCGA-13-0723-01A_lib2_all_chr1.forward'
# reads_file = "/Users/alevi/Downloads/ATCGA-13-0723-01A_lib2_all_chr1.forward/TCGA-13-0723-01A_lib2_all_chr1.forward"

chr1_reads = fread(reads_file) 
colnames(chr1_reads) = c("Chrom","Loc","FragLen")
```


## Introduction 

This week we analyzed a text-based sequencing data file used in Paired End Sequencing. It stores short reads that were generated in a Next Generation Sequencing (NGS) procedure. We attempted to identify trends in the data. To be specific, our focus was on understanding the marginal and spatial distribution of reads along the chromosome fragment being sequenced. \n

To clarify, in our work 'fragments' refers to pieces of the original DNA strand, usually of uniform length, that make up the so-called library. The entire library is then sequenced using NGS and the resulting collection of sequences vary in size and starting point, in relation to the DNA fragment being sequenced. \n

See also “Next Generation Sequencing - a Step-by-Step Guide to DNA Sequencing.” YouTube, 4 Dec. 2022, youtu.be/WKAUtJQ69n8?si=CKGYkR6w69NLurz_. \n

## Q1: GetReadloc_line function

The function takes two inputs: 1) a vector of chromosomal locations for which we have a collection of sequencing reads, and 2) a region of interest along the chromosome (start and end locations). For the given region, it outputs a vector containing the count of reads mapped to the chromosomal location, relative to the starting end. \n


```{r getReadloc_line_func, message=FALSE, warning=FALSE}

getReadloc_line = function(locations, beg_region, end_region) {
  
  # Initialize the vector to store the counts
  N = end_region - beg_region + 1
  loc_line = numeric(N)
  # loc_line = rep(0, end_region - beg_region + 1)
  
  # Loop through the locations and increment the count
  for (loc in locations) {
    
    # Increase count in corresponding index (relative to first read)
    if (loc >= beg_region && loc <= end_region) {
      loc_line[loc - beg_region + 1] = loc_line[loc - beg_region + 1] + 1
    }
  }
  
  return(loc_line)
}
```


Testing the function on 20M bases:

```{r}

locs = chr1_reads$Loc

# Define the beginning and end of the region
beg = 1
end = 20000000

start_time <- proc.time()
loc_line <- getReadloc_line(locs, beg, end)
end_time <- proc.time()

elapsed_time <- end_time - start_time

# Count non-zero values
non_zero_count <- sum(loc_line != 0)
print(paste("Function run time:", round(elapsed_time["elapsed"],2), "seconds"))
print(paste("Number of fragments:", round(non_zero_count/1000,2), "K"))

```

## Q2: Marginal Distribution of Single Locations Being Sequenced

```{r labels_func}
  # function to format the values
  format_labels <- function(x) {
    if (x >= 1e6) {return(paste0(round(x / 1e6, 2), "M"))}
    if (x >= 1e3) {return(paste0(round(x / 1e3, 1), "K"))} 
    else {return(as.character(x))
    }
  }

```

The following histogram demonstrates the marginal distribution of the given chromosome by counting the number of fragments that begin in each individual location. \n

```{r hist_locs}

# Part 1: Histogram for individual locations

# read the data and create histogram
read_hist <- hist(loc_line, breaks = 0:40 - 0.5, plot = FALSE)

# define y-axis limits
y_lim <- c(0, max(read_hist$counts) * 1.1)

# plot the histogram without y-axis
plot(read_hist, ylim = y_lim, yaxt = "n", 
     main = "Number of Chrom1 Locations Containing X Reads",
     xlab = "Read Count (Per Location)", 
     ylab = "Location Count")

# format y-axis labels
y_ticks <- axTicks(2)
formatted_y_ticks <- sapply(y_ticks, format_labels)
axis(2, at = y_ticks, labels = formatted_y_ticks)

# format histogram labels
formatted_counts <- sapply(read_hist$counts, format_labels)

# add formatted labels to the histogram
text(read_hist$mids,
     read_hist$counts,
     formatted_counts,
     pos = 3, cex = 0.35)

```

Clearly, the great majority of bins have only 1 read, or no reads at all. \n


# Count Per Aggregated Bin of Reads
```{r message=FALSE, warning=FALSE, include=FALSE}

## Binning reads into 10K bp (incl last_read)

#Preparing vector of read counts in bins of 10K
last_read = as.numeric(nrow(chr1_reads))
N10K = ceiling(last_read/20000)

reads_20K= numeric(N10K)
for (r in 1:nrow(chr1_reads)){
  biN10K = 1+floor((chr1_reads$Loc[r]-1)/20000) 
  reads_20K[biN10K] = reads_20K[biN10K]+1 
}

```

By clustering the data into bins of 10K reads each, we achieve an aggregated view of the marginal distribution. \n

```{r}
# find outliers:
h <- hist(pmin(reads_20K,4000),breaks = 100,plot = FALSE)

# define y-axis limits
# y_lim_10K <- c(0, length(reads_20K)*0.1)

# plot the histogram without y-axis
plot(h, 
     # ylim = y_lim_10K,
     yaxt = "n", 
     main = "Number of Bins Containing X Reads",
     xlab = "Read Count (Per Bin of 10K Bases)", ylab = "Number of Bins")

# format y-axis labels
y_ticks <- axTicks(2)
formatted_y_ticks <- sapply(y_ticks, format_labels)
axis(2, at = y_ticks, labels = formatted_y_ticks)

# add markers of outliers
bottom_cut = 600
top_cut = 2600

lcut_space = 50
lcut_ylim = 40

abline(v=c(bottom_cut,top_cut),col=rgb(1,0,0,1), lw=1.5)
text(x=bottom_cut-lcut_space,y=lcut_ylim, 
     labels="Cutoff of <600",
     bg="transparent",col = "red", cex = 0.7, srt=90,pos=3)
text(x=top_cut-lcut_space,y=lcut_ylim, 
     labels="Cutoff of >2600",
     bg="transparent",col = "red", cex = 0.7, srt=90,pos=3)

```
As before, the majority of bins register a very low number of reads, mostly clustering around zero, with a right-skewed distribution. \n

Yet in the center of the histogram, we now recognize a semi bell-curve distribution. \n

Seeing as the out seen to mask the central distribution, we will exclude them and further analyze the remaining bins. \n

Marked in red are the cutoff values of an average coverage below 200 and over 400 reads per bin of 10K. \n



# Zoomed-In Observation of Curved Distribution
```{r}
# logical vector s.t. TRUE if condition is met (within selected cutoff range)
no_outlier = !is.na(reads_20K) & reads_20K > 600 & reads_20K < 2600

# exclude outliers
h_no_out = hist(reads_20K[no_outlier],breaks=100, plot = FALSE)

# plot the histogram without y-axis (no explicit y-limit this time)
plot(h_no_out, yaxt = "n", 
     main = "Number of Bins Containing X Reads (Excl. Outliers)",
     xlab = "Read Count (Per Given Bin)", ylab = "Number of Bins")

# format y-axis labels
y_ticks <- axTicks(2)
formatted_y_ticks <- sapply(y_ticks, format_labels)
axis(2, at = y_ticks, labels = formatted_y_ticks)

# add markers of outliers
light_red=rgb(1,0,0,0.25)
abline(v=c(bottom_cut,top_cut),col=light_red, lw=2.5)
text(x=top_cut-15,
     y=20, 
     labels="Cutoff of <2600",
     bg="transparent",col = light_red, cex = 0.8, srt=90,pos=3)
text(x=bottom_cut-15,
     y=20, 
     labels="Cutoff of >600",
     bg="transparent",col = light_red, cex = 0.8, srt=90,pos=3)

y_stats=as.data.frame(t(summary(h_no_out$counts)))
y_max=y_stats$Freq[[6]]

x_stats=as.data.frame(t(summary(reads_20K[no_outlier])))
x_mean=x_stats$Freq[[4]]

# add marker of mean
m_no_out = mean(reads_20K[no_outlier])
segments(x0=m_no_out,x1=m_no_out,y0=0,y1=y_max-10,col="darkblue",lw=2)
text(x=x_mean, y=y_max-5, 
     labels=paste0("Avg. Count\n",round(m_no_out)),
     col = "darkblue", cex = 0.8)



```

By filtering out records of extreme read counts per bin, we recognize what seema to be a double-hump around the center of the bell-curve. \n
This may possibly indicate the existence of two overlapping distributions. \n


## Zoom in to a limited range of locations (no larger than cutoff)


We decided to exclude bins over 4,000 to display the trend in read counts, graph can be more clear.

```{r}

# pmin: for each in given vector (arg1), compare to arg2 & choose the minimal
r10K_pmin4K = pmin(reads_20K,4000) # 4K cutoff
r10K_pmin6K = pmin(reads_20K,6000) # 6K cutoff
r10K_pmin10K = pmin(reads_20K,10000) # 10K cutoff

h_pmin10k = hist(r10K_pmin4K,breaks = 100)

```



#Q4
```{r}
# Convert vector to a data frame
read_counts_df <- data.frame(
  Count = loc_line,
  Location = seq(beg_region, end_region)
)

head(read_counts_df)
```
```{r}
# Fit a normal distribution to the read counts
mean_read_counts = mean(read_counts_df$Count)
sd_read_counts = sd(read_counts_df$Count)

# Create a histogram of the read counts
p <- ggplot(read_counts_df, aes(x = Count)) +
  geom_histogram(aes(y = ..density..), binwidth = 1, color = "black", fill = "white") +
  stat_function(fun = dnorm, args = list(mean = mean_read_counts, sd = sd_read_counts), color = "red", size = 1) +
  labs(title = "Histogram of Read Counts with Fitted Normal Distribution",
       x = "Number of Reads",
       y = "Density") +
  theme_minimal()

print(p)

```


The histogram shows that the majority of locations have a very low number of reads, mostly clustering around zero, with a right-skewed distribution.

The fitted normal distribution (red loc_line) does not match the histogram well.
The normal distribution is symmetric and bell-shaped, which does not align with the right-skewed nature of the read count distribution.
The histogram's peak is at the beginning (near zero), while the normal distribution's peak is at the mean, leading to a poor fit.
The normal distribution is not suitable for this data due to its right-skewed nature and the heavy concentration of low read counts.



## Short summary

It is clear from the data that we have two pairs of bases, in all cases C-G is a stronger pair then A-T. It will be interesting to further research the chromosome based on this understanding. 
