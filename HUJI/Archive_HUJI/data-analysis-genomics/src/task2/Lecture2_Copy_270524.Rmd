---
title: "Lecture2"
author: "Yuval Benjamini"
date: "21 May, 2024"
output:
  html_document:
    code_folding: show
  pdf_document: default
editor_options:
  markdown:
    wrap: sentence
---

## Load R libraries

```{r libraries, message=FALSE, warning=FALSE}
  library('data.table')
  library('tictoc')
  library('manipulate')

```

## Read the file

```{r}

# Original file
# reads_file = '~/Carmel/RProjects/Lab_Benjamini/data/TCGA-13-0723-01A_lib2_all_chr1.forward'

# Group A file
reads_file = '~/Carmel/RProjects/Lab_Benjamini/data/TCGA-13-0723-10B_lib2_all_chr1.forward'


# fread is a more efficient function for reading large tables from files
chr1_reads = fread(reads_file) 

# adding column names:
colnames(chr1_reads) = c("Chrom","Loc","FragLen")   

head(chr1_reads)
summary(chr1_reads)
```

## [SKIP] Calculate metrics of read depth (incl last_read_1, not last_read)

```{r}
# goes to last entry in data and retrieves its location (loc in chromosome 1)
dat_rows = nrow(chr1_reads)
last_read_1 = chr1_reads[dat_rows,"Loc"] 

# Avg. Read Depth
# total(Reads)/total(Bases)
coverage = dat_rows / last_read_1

# Avg. Distance Between Reads
# total(Bases)/total(Reads)
avg_dis = 1/coverage # divides full data length by avg

print(c(LastRead=last_read_1,
        Coverage=coverage,
        AvgDist=avg_dis))

```

## [SKIP] Create read_line_1 (read_line is below)

How many reads at each point?

```{r read_line_1}
beg_region = 1
end_region = 10000000
N = end_region-beg_region+1

# prepare read_line_1 of size N 
read_line_1 = numeric(N)

# tic toc measures how long code takes to run.
tic()
# so that read_line_1[i] is the number of reads beginning at i
for (i in 1:100){
  
  # if a location i appears in dataset, add 1 to value of corresp. index
  read_line_1[i] = sum(chr1_reads$Loc == (i+beg_region-1))
  
}
toc()
# circa 20 seconds

```

## Creating read_line

So we should make this algorithm more efficient. Here is one attempt.

```{r read_line}

# prepare read_line of size N 
beg_region = 1
end_region = 10000000
N = end_region-beg_region+1
read_line = numeric(N)

tic()
first_read = min(which(chr1_reads$Loc >= beg_region)) 
r = first_read

# Use proc.time when the command is not a one line. 
# It measures current time, and can be subtracted out.
tt = proc.time()

while (chr1_reads$Loc[r] <= end_region){
  read_line[chr1_reads$Loc[r]] = read_line[chr1_reads$Loc[r]]+1
  r = r+1
}
toc()
# circa 5-9 seconds

```

Things to remember when trying to be efficient: - Always have a slow implementation that you know is correct before making efficient - Check that this is really what you need to optimize

## Rewrite as a function

(this is for you...)

```{r}
getReadLine = function(locations, beg_region, end_region){
  # Assumptions: locations is a sorted vector of beginnings
  # Don't forget - what happens if beg_region is not equal to 1?
  
  # Complete....
  
  return(line)
}
```

```{r}


opar <- options(scipen=100)

read_hist = hist(line,breaks = 0:40-0.5,
                 ylim = c(0, 500000))
text(read_hist$mids,
     read_hist$counts,
     read_hist$counts,
     pos = 3,cex =0.5)

par(opar) ## restore original settings 

```

Is the distribution of reads uniform? That would lead to a Poisson marginal distribution...

## Binning reads into 10000 bp (incl last_read)

Preparing our read line (i.e. vec of counts in bin of 10K)...

```{r include=FALSE}
last_read = as.numeric(chr1_reads[nrow(chr1_reads),"Loc"])
N10K = ceiling(last_read/10000)

reads_10K= numeric(N10K)
for (r in 1:nrow(chr1_reads)){
  biN10K = 1+floor((chr1_reads$Loc[r]-1)/10000) 
  reads_10K[biN10K] = reads_10K[biN10K]+1 
}

```

## Identify outliers by looking at marginal distribution

1 dimensional display

```{r}
# most reads are mapped to the value 0 or 1
summary(reads_10K)

# this makes the histogram very marginalized
# can't see anything, most values are plotted to a single bar
hist(reads_10K)

hist(log10(reads_10K))

# therefore, we need to control the plot size
# we'll demonstrate using boxplots:
boxplot(reads_10K)

# controlling maximum range of the y-axis
# boxplot(line,ylim = c(0,30000))
# boxplot(line,ylim = c(0,10000))

# rotating the box-plot by 90 degrees
# boxplot(line,ylim = c(0,10000),horizontal = TRUE)

```

## x.zoom in to a limited range of values (no large than cutoff)

```{r}

# pmin: for each in given vector (arg1), compare to arg2 & choose the minimal
cutoff=4000
r10K_pmin4K = pmin(reads_10K[0:1000],cutoff) # 4K cutoff
# r10K_pmin6K = pmin(reads_10K,6000) # 6K cutoff
# r10K_pmin10K = pmin(reads_10K,10000) # 10K cutoff

# verify that indeed the maximum is at 10K:
summary(r10K_pmin4K)

# create histograms
# h = hist(r10K_pmin10K,breaks = 100)
# h2 = hist(r10K_pmin6K,breaks = 100)
h3 = hist(r10K_pmin4K,breaks = 100)

# find outlier cutoffs:
btm_cut = 20
top_cut = 300
abline(h=cutoff, col="red")
no_outlier = reads_10K>btm_cut &reads_10K<top_cut
mean(no_outlier) #proportion of non-outlier

# estimate density of distribution body
h_no_out = hist(reads_10K[no_outlier],breaks=100)

m_no_outliers =mean(reads_10K[no_outlier])
abline(v=m_no_outliers,col="red",lw=2)
```


## Graphical Settings in Scatter Plots

```{r}
# below are variations of same plot, diff settings

plot(reads_10K)
plot(reads_10K,ylim=c(0,30000)) # cutoff at 30K
plot(reads_10K,ylim=c(0,20000)) # cutoff at 20K
plot(reads_10K,ylim=c(0,10000),col = rgb(0,0,0,0.4), cex=0.7) 

# find and color only the outlier points (freq above 6K)
outlier_above = which(reads_10K > 6000)
points(outlier_above,rep(6000,length(outlier_above)),col=2,cex =1.1, pch=20)
text(outlier_above, labels=paste(outlier_above, sep=","))

plot(reads_10K,ylim=c(0,10000),col = rgb(0,0,0,0.5)) # lighter hue
points(outlier_above,rep(6000,length(outlier_above)),col=2,cex =0.2)

plot(reads_10K,ylim=c(0,10000),col = rgb(0,0,0,0.5)) # lighter hue
points(outlier_above,rep(6000,length(outlier_above)),col=2,cex =0.6)

plot(reads_10K,ylim=c(0,10000),col = rgb(0,0,0,0.5)) # lighter hue
points(outlier_above,rep(6000,length(outlier_above)),col=2,cex =0.9)

plot(reads_10K,ylim=c(0,10000),col = rgb(0,0,0,0.4), cex=0.7) 
points(outlier_above,rep(6000,length(outlier_above)),col=2,cex =1.1, pch=20)
text(outlier_above, labels=paste(outlier_above, sep=","))
# col controls color, supports rgb(red,green,blue,hue)
# cex controls size of points
```


## Zoom In On X-Axis & Add Trend Line
```{r}
x.zoom=10000:length(line)

# plot then add a smoothing line that shows trends
plot(x.zoom, reads_10K[x.zoom],ylim = c(0,1000),col = rgb(0,0,0,0.5),cex =0.5)
lines(col=4, lw=3, x=loess.smooth(x.zoom, reads_10K[x.zoom]))

# smoothing line at higher resolution (less smoothing)
plot(x.zoom, reads_10K[x.zoom],ylim=c(0,1000),col = rgb(0,0,0,0.5),cex =0.5)
lines(col=4, lw=3, x=loess.smooth(x.zoom, reads_10K[x.zoom],span = 0.01))
```


## Iterating Over Zoom Region
```{r}
# range must be within length of reads_... being plotted
x.zoom1=1:20000000
x.zoom2=10000:13000
x.zoom3=13000:20000
x.zoom4=20000:length(reads_10K) 

plot(x.zoom1,reads_10K[x.zoom1],ylim=c(0,1000),col = rgb(0,0,0,0.5),cex =0.5)
lines(loess.smooth(x.zoom1,reads_10K[x.zoom1],span = 0.01),col=4,lw=3)

plot(x.zoom2,reads_10K[x.zoom2],ylim=c(0,1000),col = rgb(0,0,0,0.5),cex =0.5)
lines(loess.smooth(x.zoom2,reads_10K[x.zoom2],span = 0.01),col=4,lw=3)

plot(x.zoom3,reads_10K[x.zoom3],ylim=c(0,1000),col = rgb(0,0,0,0.5),cex =0.5)
lines(loess.smooth(x.zoom3,reads_10K[x.zoom3],span = 0.01),col=4,lw=3)

plot(x.zoom4,reads_10K[x.zoom4],ylim=c(0,1000),col = rgb(0,0,0,0.5),cex =0.5)
lines(loess.smooth(x.zoom4,reads_10K[x.zoom4],span = 0.01),col=4,lw=3)

# full x axis (y axis cutoff at 4K)
x.zoom5=1:length(reads_10K)
plot(x.zoom5, reads_10K[x.zoom5],ylim = c(0,4000),col = rgb(0,0,0,0.5),cex =0.5)
lines(loess.smooth(x.zoom5,reads_10K[x.zoom5],span = 0.01),col=4,lw=3)

# another x axis zoom-in (y axis cutoff at 2K)
x.zoom6=3000:8000
plot(x.zoom6,reads_10K[x.zoom6],ylim=c(0,2000),col = rgb(0,0,0,0.5),cex =0.5)
lines(loess.smooth(x.zoom6,reads_10K[x.zoom6],span = 0.01),col=4,lw=3)


```


## R plots with sliders
Explore the graph using the "manipulate" package. 
This doesn't work well in Markdown, so copy the entire snippet and run it in the RStudio console.

```{r,eval = FALSE}
# Define the plotting function
plot_with_abline <- function(x) {
  plot(x + (1:pl), reads_10K[x + (1:pl)], ylim = c(0, 6000), pch = 20, cex = 0.8)
  abline(h = 4000, col = "red", lw = 2)
}

# Use manipulate to add interactivity (run in console)
manipulate(
  plot_with_abline(x),
  x = slider(1, length(reads_10K) - pl + 1, initial = 200)
)
```
