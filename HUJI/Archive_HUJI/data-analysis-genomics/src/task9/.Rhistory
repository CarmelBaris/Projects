f = function(X_cln, Y_cln, deg = 3, knots) {
# f = function(X, Y, deg = 3, knots, subs) {
# Ensure X and Y lengths match before fitting the model
# X_cln = X[subs]
# Y_cln = Y[subs]
# Check for and remove NA or non-finite values
# finite_indices = which(is.finite(X_cln) & is.finite(Y_cln))
# X_cln = X_cln[finite_indices]
# Y_cln = Y_cln[finite_indices]
cat("Length of X_cln",length(X_cln),"\n")
cat("Length of Y_cln",length(Y_cln),"\n")
cat("Summary of X_cln","\n")
print(summary(X_cln))
cat("Summary of Y_cln","\n")
print(summary(Y_cln))
lm(Y_cln ~ splines::bs(X_cln, degree = deg, knots = knots, Boundary.knots = c(min(X_cln), max(X_cln))))
}
# Example usage with adjusted function f
# Ensure all necessary data is cleaned and matches in length
l_2n = length(r_health_cln)
pred_range = seq(0.2, 0.75, 0.01)
GC = GC_cln[1:l_2n]
# Define subsets for filtering
subs_n = (r_health_cln > 50) & (r_health_cln < 350)
subs_t = (r_tumor_cln > 50) & (r_tumor_cln < 350)
# Fit models using the updated function
mod_2n = f(GC_above0, r_health_cln, 3, knots_list[[1]])
# outputs evenly spaced knot vectors for different numbers of knots
create_knots <- function(x, min_knots = 1, max_knots = 10) {
min_x <- min(x)
max_x <- max(x)
knots_list <- lapply(min_knots:max_knots, function(k) {
seq(min_x, max_x, length.out = k + 2)[-c(1, k + 2)]
})
return(knots_list)
}
# Exclude 0 values from the GC range
GC_above0 <- GC_cln[GC_cln != 0]
r_health_above0 <- r_health_cln[GC_cln != 0]
r_tumor_above0 <- r_tumor_cln[GC_cln != 0]
knots_list_nonzero <- create_knots(GC_above0)
# Exclude GC values smaller than 0.3
GC_above.3 <- GC_cln[GC_cln >= 0.3]
r_health_above.3 <- r_health_cln[GC_cln >= 0.3]
r_tumor_above.3 <- r_tumor_cln[GC_cln >= 0.3]
knots_list_filtered <- create_knots(GC_above.3)
# Create knot vectors for original data
knots_list <- create_knots(GC_cln)
# Display knot vectors
# knots_list
# knots_list_nonzero
# knots_list_filtered
f = function(X_cln, Y_cln, deg = 3, knots) {
# f = function(X, Y, deg = 3, knots, subs) {
# Ensure X and Y lengths match before fitting the model
# X_cln = X[subs]
# Y_cln = Y[subs]
# Check for and remove NA or non-finite values
# finite_indices = which(is.finite(X_cln) & is.finite(Y_cln))
# X_cln = X_cln[finite_indices]
# Y_cln = Y_cln[finite_indices]
cat("Length of X_cln",length(X_cln),"\n")
cat("Length of Y_cln",length(Y_cln),"\n")
cat("Summary of X_cln","\n")
print(summary(X_cln))
cat("Summary of Y_cln","\n")
print(summary(Y_cln))
lm(Y_cln ~ splines::bs(X_cln, degree = deg, knots = knots, Boundary.knots = c(min(X_cln), max(X_cln))))
}
# Example usage with adjusted function f
# Ensure all necessary data is cleaned and matches in length
l_2n = length(r_health_cln)
pred_range = seq(0.2, 0.75, 0.01)
GC = GC_cln[1:l_2n]
# Define subsets for filtering
subs_n = (r_health_cln > 50) & (r_health_cln < 350)
subs_t = (r_tumor_cln > 50) & (r_tumor_cln < 350)
# Fit models using the updated function
mod_2n = f(GC_above0, r_health_cln, 3, knots_list[[1]])
```{r new}
l_2n = length(r_health_cln)
pred_range = seq(0.2, 0.75, 0.01)
GC = GC_cln[1:l_2n]
# Define subsets for filtering
subs_n = (r_health_cln > 50) & (r_health_cln < 350)
subs_t = (r_tumor_cln > 50) & (r_tumor_cln < 350)
# Fit models using the updated function
mod_2n = f(GC_above0, r_health_cln, 3, knots_list[[1]])
f = function(X_cln, Y_cln, deg = 3, knots) {
# f = function(X, Y, deg = 3, knots, subs) {
# Ensure X and Y lengths match before fitting the model
# X_cln = X[subs]
# Y_cln = Y[subs]
# Check for and remove NA or non-finite values
# finite_indices = which(is.finite(X_cln) & is.finite(Y_cln))
# X_cln = X_cln[finite_indices]
# Y_cln = Y_cln[finite_indices]
cat("Length of X_cln",length(X_cln),"\n")
cat("Length of Y_cln",length(Y_cln),"\n")
cat("Summary of X_cln","\n")
print(summary(X_cln))
cat("Summary of Y_cln","\n")
print(summary(Y_cln))
lm(Y_cln ~ splines::bs(X_cln, degree = deg, knots = knots, Boundary.knots = c(min(X_cln), max(X_cln))))
}
# Example usage with adjusted function f
# Ensure all necessary data is cleaned and matches in length
l_2n = length(r_health_cln)
pred_range = seq(0.2, 0.75, 0.01)
GC = GC_cln[1:l_2n]
# Define subsets for filtering
subs_n = (r_health_cln > 50) & (r_health_cln < 350)
subs_t = (r_tumor_cln > 50) & (r_tumor_cln < 350)
# Fit models using the updated function
mod_2n = f(GC_above0, r_health_above0, 3, knots_list[[1]])
# mod_2n = f(GC, r_health_cln, 3, knots_list[[1]], subs_n)
mod_2t = f(GC_above0, r_tumor_above0, 3, knots_list[[1]])
# mod_2t = f(GC, r_tumor_cln, 3, knots_list[[1]], subs_t)
# Make predictions
predict_data = data.frame(GC_above0 = seq(0, 0.7, 0.01))
predict_data$resp2n = predict(mod_2n, predict_data)
length(seq(0, 0.7, 0.01)
)
f = function(X_cln, Y_cln, deg = 3, knots) {
# f = function(X, Y, deg = 3, knots, subs) {
# Ensure X and Y lengths match before fitting the model
# X_cln = X[subs]
# Y_cln = Y[subs]
# Check for and remove NA or non-finite values
# finite_indices = which(is.finite(X_cln) & is.finite(Y_cln))
# X_cln = X_cln[finite_indices]
# Y_cln = Y_cln[finite_indices]
cat("Length of X_cln",length(X_cln),"\n")
cat("Length of Y_cln",length(Y_cln),"\n")
cat("Summary of X_cln","\n")
print(summary(X_cln))
cat("Summary of Y_cln","\n")
print(summary(Y_cln))
lm(Y_cln ~ splines::bs(X_cln, degree = deg, knots = knots, Boundary.knots = c(min(X_cln), max(X_cln))))
}
# Example usage with adjusted function f
# Ensure all necessary data is cleaned and matches in length
l_2n = length(r_health_cln)
pred_range = seq(0.2, 0.75, 0.01)
GC = GC_cln[1:l_2n]
# Define subsets for filtering
subs_n = (r_health_cln > 50) & (r_health_cln < 350)
subs_t = (r_tumor_cln > 50) & (r_tumor_cln < 350)
# Fit models using the updated function
mod_2n = f(GC_above0, r_health_above0, 3, knots_list[[1]])
# mod_2n = f(GC, r_health_cln, 3, knots_list[[1]], subs_n)
mod_2t = f(GC_above0, r_tumor_above0, 3, knots_list[[1]])
# mod_2t = f(GC, r_tumor_cln, 3, knots_list[[1]], subs_t)
# Make predictions
predict_data = data.frame(GC_above0 = seq(0, 0.1*length(GC_above0), 0.01))
predict_data$resp2n = predict(mod_2n, predict_data)
f = function(X_cln, Y_cln, deg = 3, knots) {
# f = function(X, Y, deg = 3, knots, subs) {
# Ensure X and Y lengths match before fitting the model
# X_cln = X[subs]
# Y_cln = Y[subs]
# Check for and remove NA or non-finite values
# finite_indices = which(is.finite(X_cln) & is.finite(Y_cln))
# X_cln = X_cln[finite_indices]
# Y_cln = Y_cln[finite_indices]
cat("Length of X_cln",length(X_cln),"\n")
cat("Length of Y_cln",length(Y_cln),"\n")
cat("Summary of X_cln","\n")
print(summary(X_cln))
cat("Summary of Y_cln","\n")
print(summary(Y_cln))
lm(Y_cln ~ splines::bs(X_cln, degree = deg, knots = knots, Boundary.knots = c(min(X_cln), max(X_cln))))
}
# Example usage with adjusted function f
# Ensure all necessary data is cleaned and matches in length
l_2n = length(r_health_cln)
pred_range = seq(0.2, 0.75, 0.01)
GC = GC_cln[1:l_2n]
# Define subsets for filtering
subs_n = (r_health_cln > 50) & (r_health_cln < 350)
subs_t = (r_tumor_cln > 50) & (r_tumor_cln < 350)
# Fit models using the updated function
mod_2n = f(GC_above0, r_health_above0, 3, knots_list[[1]])
# mod_2n = f(GC, r_health_cln, 3, knots_list[[1]], subs_n)
mod_2t = f(GC_above0, r_tumor_above0, 3, knots_list[[1]])
# mod_2t = f(GC, r_tumor_cln, 3, knots_list[[1]], subs_t)
# Make predictions
predict_data = data.frame(GC_above0 = seq(0, 0.1*(length(GC_above0)-1), 0.01))
predict_data$resp2n = predict(mod_2n, predict_data)
f = function(X_cln, Y_cln, deg = 3, knots) {
# f = function(X, Y, deg = 3, knots, subs) {
# Ensure X and Y lengths match before fitting the model
# X_cln = X[subs]
# Y_cln = Y[subs]
# Check for and remove NA or non-finite values
# finite_indices = which(is.finite(X_cln) & is.finite(Y_cln))
# X_cln = X_cln[finite_indices]
# Y_cln = Y_cln[finite_indices]
cat("Length of X_cln",length(X_cln),"\n")
cat("Length of Y_cln",length(Y_cln),"\n")
cat("Summary of X_cln","\n")
print(summary(X_cln))
cat("Summary of Y_cln","\n")
print(summary(Y_cln))
lm(Y_cln ~ splines::bs(X_cln, degree = deg, knots = knots, Boundary.knots = c(min(X_cln), max(X_cln))))
}
# Example usage with adjusted function f
# Ensure all necessary data is cleaned and matches in length
l_2n = length(r_health_cln)
pred_range = seq(0.2, 0.75, 0.01)
GC = GC_cln[1:l_2n]
# Define subsets for filtering
subs_n = (r_health_cln > 50) & (r_health_cln < 350)
subs_t = (r_tumor_cln > 50) & (r_tumor_cln < 350)
# Fit models using the updated function
mod_2n = f(GC_above0, r_health_above0, 3, knots_list[[1]])
# mod_2n = f(GC, r_health_cln, 3, knots_list[[1]], subs_n)
mod_2t = f(GC_above0, r_tumor_above0, 3, knots_list[[1]])
# mod_2t = f(GC, r_tumor_cln, 3, knots_list[[1]], subs_t)
# Make predictions
predict_data = data.frame(GC_above0 = seq(0, 0.1*length(GC_above0), 0.01))
predict_data$resp2n = predict(mod_2n, predict_data)
f = function(X_cln, Y_cln, deg = 3, knots) {
# f = function(X, Y, deg = 3, knots, subs) {
# Ensure X and Y lengths match before fitting the model
# X_cln = X[subs]
# Y_cln = Y[subs]
# Check for and remove NA or non-finite values
# finite_indices = which(is.finite(X_cln) & is.finite(Y_cln))
# X_cln = X_cln[finite_indices]
# Y_cln = Y_cln[finite_indices]
cat("Length of X_cln",length(X_cln),"\n")
cat("Length of Y_cln",length(Y_cln),"\n")
cat("Summary of X_cln","\n")
print(summary(X_cln))
cat("Summary of Y_cln","\n")
print(summary(Y_cln))
lm(Y_cln ~ splines::bs(X_cln, degree = deg, knots = knots, Boundary.knots = c(min(X_cln), max(X_cln))))
}
# Example usage with adjusted function f
# Ensure all necessary data is cleaned and matches in length
l_2n = length(r_health_cln)
pred_range = seq(0.2, 0.75, 0.01)
GC = GC_cln[1:l_2n]
# Define subsets for filtering
subs_n = (r_health_cln > 50) & (r_health_cln < 350)
subs_t = (r_tumor_cln > 50) & (r_tumor_cln < 350)
# Fit models using the updated function
mod_2n = f(GC_above0, r_health_above0, 3, knots_list[[1]])
# mod_2n = f(GC, r_health_cln, 3, knots_list[[1]], subs_n)
mod_2t = f(GC_above0, r_tumor_above0, 3, knots_list[[1]])
# mod_2t = f(GC, r_tumor_cln, 3, knots_list[[1]], subs_t)
# Make predictions
predict_data = data.frame(seq(0, 0.1*length(GC_above0), 0.01))
predict_data$resp2n = predict(mod_2n, predict_data)
View(mod_2n)
.1*length(GC_above0)
f = function(X_cln, Y_cln, deg = 3, knots) {
# f = function(X, Y, deg = 3, knots, subs) {
# Ensure X and Y lengths match before fitting the model
# X_cln = X[subs]
# Y_cln = Y[subs]
# Check for and remove NA or non-finite values
# finite_indices = which(is.finite(X_cln) & is.finite(Y_cln))
# X_cln = X_cln[finite_indices]
# Y_cln = Y_cln[finite_indices]
cat("Length of X_cln",length(X_cln),"\n")
cat("Length of Y_cln",length(Y_cln),"\n")
cat("Summary of X_cln","\n")
print(summary(X_cln))
cat("Summary of Y_cln","\n")
print(summary(Y_cln))
lm(Y_cln ~ splines::bs(X_cln, degree = deg, knots = knots, Boundary.knots = c(min(X_cln), max(X_cln))))
}
# Example usage with adjusted function f
# Ensure all necessary data is cleaned and matches in length
l_2n = length(r_health_cln)
pred_range = seq(0.2, 0.75, 0.01)
GC = GC_cln[1:l_2n]
# Define subsets for filtering
subs_n = (r_health_cln > 50) & (r_health_cln < 350)
subs_t = (r_tumor_cln > 50) & (r_tumor_cln < 350)
# Fit models using the updated function
mod_2n = f(GC_above0, r_health_above0, 3, knots_list[[1]])
# mod_2n = f(GC, r_health_cln, 3, knots_list[[1]], subs_n)
mod_2t = f(GC_above0, r_tumor_above0, 3, knots_list[[1]])
# mod_2t = f(GC, r_tumor_cln, 3, knots_list[[1]], subs_t)
# Make predictions
predict_data = data.frame(seq(0, length(GC_above0), 0.01))
predict_data$resp2n = predict(mod_2n, predict_data)
f = function(X_cln, Y_cln, deg = 3, knots) {
# f = function(X, Y, deg = 3, knots, subs) {
# Ensure X and Y lengths match before fitting the model
# X_cln = X[subs]
# Y_cln = Y[subs]
# Check for and remove NA or non-finite values
# finite_indices = which(is.finite(X_cln) & is.finite(Y_cln))
# X_cln = X_cln[finite_indices]
# Y_cln = Y_cln[finite_indices]
cat("Length of X_cln",length(X_cln),"\n")
cat("Length of Y_cln",length(Y_cln),"\n")
cat("Summary of X_cln","\n")
print(summary(X_cln))
cat("Summary of Y_cln","\n")
print(summary(Y_cln))
lm(Y_cln ~ splines::bs(X_cln, degree = deg, knots = knots, Boundary.knots = c(min(X_cln), max(X_cln))))
}
# Example usage with adjusted function f
# Ensure all necessary data is cleaned and matches in length
l_2n = length(r_health_cln)
pred_range = seq(0.2, 0.75, 0.01)
GC = GC_cln[1:l_2n]
# Define subsets for filtering
subs_n = (r_health_cln > 50) & (r_health_cln < 350)
subs_t = (r_tumor_cln > 50) & (r_tumor_cln < 350)
# Fit models using the updated function
mod_2n = f(GC_above0, r_health_above0, 3, knots_list[[1]])
# mod_2n = f(GC, r_health_cln, 3, knots_list[[1]], subs_n)
mod_2t = f(GC_above0, r_tumor_above0, 3, knots_list[[1]])
# mod_2t = f(GC, r_tumor_cln, 3, knots_list[[1]], subs_t)
# Make predictions
predict_data = data.frame(seq(0, 0.1*length(GC_above0), 0.01))
predict_data$resp2n = predict(mod_2n, predict_data)
0.1*length(GC_above0)
round(0.1*length(GC_above0))
f = function(X_cln, Y_cln, deg = 3, knots) {
# f = function(X, Y, deg = 3, knots, subs) {
# Ensure X and Y lengths match before fitting the model
# X_cln = X[subs]
# Y_cln = Y[subs]
# Check for and remove NA or non-finite values
# finite_indices = which(is.finite(X_cln) & is.finite(Y_cln))
# X_cln = X_cln[finite_indices]
# Y_cln = Y_cln[finite_indices]
cat("Length of X_cln",length(X_cln),"\n")
cat("Length of Y_cln",length(Y_cln),"\n")
cat("Summary of X_cln","\n")
print(summary(X_cln))
cat("Summary of Y_cln","\n")
print(summary(Y_cln))
lm(Y_cln ~ splines::bs(X_cln, degree = deg, knots = knots, Boundary.knots = c(min(X_cln), max(X_cln))))
}
# Example usage with adjusted function f
# Ensure all necessary data is cleaned and matches in length
l_2n = length(r_health_cln)
pred_range = seq(0.2, 0.75, 0.01)
GC = GC_cln[1:l_2n]
# Define subsets for filtering
subs_n = (r_health_cln > 50) & (r_health_cln < 350)
subs_t = (r_tumor_cln > 50) & (r_tumor_cln < 350)
# Fit models using the updated function
mod_2n = f(GC_above0, r_health_above0, 3, knots_list[[1]])
# mod_2n = f(GC, r_health_cln, 3, knots_list[[1]], subs_n)
mod_2t = f(GC_above0, r_tumor_above0, 3, knots_list[[1]])
# mod_2t = f(GC, r_tumor_cln, 3, knots_list[[1]], subs_t)
# Make predictions
predict_data = data.frame(seq(0, length(GC_above0), 0.01))
predict_data$resp2n = predict(mod_2n, predict_data)
rm(list = ls())
color_tumor = rgb(0.8, 0.8, 0.8, 0.6)
col_healthy = rgb(0.3, 0.3, 0.3, 0.4)
library('splines')
path = "~/Carmel/RProjects/Lab_Benjamini/data"
# path = "/Users/alevi/Downloads/"
# path = "\\Users\\shawn\\Desktop\\"
load(sprintf("%s/reads_100_A2.rda",path))
load(sprintf("%s/reads_100_B2.rda",path))
load(sprintf("%s/GC_100.rda",path))
binsize = 25
chr2t_mat = matrix(reads_100_A2, nr = binsize)
chr2n_mat = matrix(reads_100_B2, nr = binsize)
GC_100=GC_100[1: (length(reads_100_A2)) ]
gc_mat = matrix(GC_100,nr=binsize)
reads2.5K_t2 = colSums(chr2t_mat)
reads2.5K_n2 = colSums(chr2n_mat)
GC2.5K = colMeans(gc_mat)
length(reads2.5K_n2) == length(reads2.5K_t2)
rm("chr2n_mat","chr2t_mat","gc_mat","reads_100_A2","reads_100_B2","GC_100") # remove from memory
length(reads2.5K_t2)
f <- function(x, y,knots, degree) {
mod = lm(y~bs(x,knots = knots, degree = degree))
return (mod)
}
knots = c(11,13,16)
model_t = bspline_mod(GC2.5K, reads2.5K_t2, knots, 3)
model_t = f(GC2.5K, reads2.5K_t2, knots, 3)
model_n = f(GC2.5K, reads2.5K_n2, knots, 3)
f <- function(x, y, knots) {
mod = lm(y~splines::bs(x,knots = knots, degree = 3,
Boundary.knots = c(min(x), max(x))))
return (mod)
}
model_t = f(GC2.5K, reads2.5K_t2, knots)
model_n = f(GC2.5K, reads2.5K_n2, knots)
f <- function(x, y, knots) {
mod = lm(y~splines::bs(x,knots = knots, degree = 3,
Boundary.knots = c(min(x), max(x))))
return (mod)
}
# outputs evenly spaced knot vectors for different numbers of knots
create_knots <- function(x, min_knots = 1, max_knots = 10) {
min_x <- min(x)
max_x <- max(x)
knots_list <- lapply(min_knots:max_knots, function(k) {
seq(min_x, max_x, length.out = k + 2)[-c(1, k + 2)]
})
return(knots_list)
}
knots = c(11,13,16)
# Create knot vectors for original data
knots_list <- create_knots(GC2.5K)
model_t = f(GC2.5K, reads2.5K_t2, knots_list[[1]])
model_n = f(GC2.5K, reads2.5K_n2, knots_list[[1]])
summary(model_t)
summary(model_t$coefficients)
length(model_t$coefficients)
model_t$coefficients
plot(model_n)
plot(model_n)
subs_n = (reads2.5K_n2 > 50) & (reads2.5K_n2 < 350)
subs_t = (reads2.5K_t2 > 50) & (reads2.5K_t2 < 350)
sum(reads2.5K_t2)
sum(subs_n)
sum(subs_t)
length(reads2.5K_n2)
length(reads2.5K_t2)
sum(subs_n==subs_t)
sum((subs_n==TRUE)&(subs_t==FALSE))
sum((subs_n!=TRUE)&(subs_t!=FALSE))
subs_n = (reads2.5K_n2 < 50) & (reads2.5K_n2 > 350)
subs_t = (reads2.5K_t2 < 50) & (reads2.5K_t2 > 350)
subs_n = (reads2.5K_n2 < 50) | (reads2.5K_n2 > 350)
subs_t = (reads2.5K_t2 < 50) | (reads2.5K_t2 > 350)
subs_t = (reads2.5K_t2 > 350)
subs_n = (reads2.5K_n2 > 350)
subs_n
sum(subs_n!=subs_t)
(subs_n!=subs_t)
summary(subs_n!=subs_t)
length(subs_n!=subs_t)
sum(subs_n!=subs_t)
subs_n = (reads2.5K_n2 < 50)
subs_t = (reads2.5K_t2 < 50)
sum(subs_n!=subs_t)
subs_t = (reads2.5K_t2 < 50) | (reads2.5K_t2 > 350)
subs_n = (reads2.5K_n2 < 50) | (reads2.5K_n2 > 350)
rm("subs_n", "subs_t")
rm("knots")
rm("path")
out_n = (reads2.5K_n2 < 50) | (reads2.5K_n2 > 350)
out_t = (reads2.5K_t2 < 50) | (reads2.5K_t2 > 350)
summary(reads2.5K_n2)
summary(reads2.5K_n2[out_n])
summary(reads2.5K_n2[!out_n])
plot(reads2.5K_n2[!out_n])
rm(list = ls())
color_tumor = rgb(0.8, 0.8, 0.8, 0.6)
col_healthy = rgb(0.3, 0.3, 0.3, 0.4)
library('splines')
path = "~/Carmel/RProjects/Lab_Benjamini/data"
# path = "/Users/alevi/Downloads/"
# path = "\\Users\\shawn\\Desktop\\"
load(sprintf("%s/reads_100_A2.rda",path))
load(sprintf("%s/reads_100_B2.rda",path))
load(sprintf("%s/GC_100.rda",path))
binsize = 25
chr2t_mat = matrix(reads_100_A2, nr = binsize)
chr2n_mat = matrix(reads_100_B2, nr = binsize)
GC_100=GC_100[1: (length(reads_100_A2)) ]
gc_mat = matrix(GC_100,nr=binsize)
reads2.5K_t2 = colSums(chr2t_mat)
reads2.5K_n2 = colSums(chr2n_mat)
GC2.5K = colMeans(gc_mat)
length(reads2.5K_n2) == length(reads2.5K_t2)
rm("chr2n_mat","chr2t_mat","gc_mat","reads_100_A2","reads_100_B2","GC_100") # remove from memory
rm("path")
par(mfcol =c(2,1),mar =c(1,1,1,1))
set.seed(50)
samp1 = sample(length(reads_5K_n),5000)
par(mfcol =c(2,1),mar =c(1,1,1,1))
set.seed(50)
samp1 = sample(length(reads_2.5K_n),5000)
par(mfcol =c(2,1),mar =c(1,1,1,1))
set.seed(50)
samp1 = sample(length(reads2.5K_n2),5000)
plot(GC2.5K[samp1],reads2.5K_n2[samp1],ylim = c(0,600),xlim = c(0.2,.75), cex = 0.5, pch=20)
plot(GC2.5K[samp1],reads2.5K_t2[samp1],ylim = c(0,600),xlim = c(0.2,.75),cex = 0.5, pch=20)
l_1n = length(reads_5K_n)
l_1n = length(reads2.5K_n2)
l_1t = length(reads2.5K_t2)
par(mfcol = c(1,1))
plot(GC2.5K[samp1],reads2.5K_n2[samp1],ylim = c(0,600),xlim = c(0.2,.75), cex = 0.5, pch=20)
mod_1n = lm(reads2.5K_n2~bs(GC2.5K,deg = 3,knots = c(seq(0.25,0.6,0.025),0.65)),subset = (reads2.5K_n2>50 & reads2.5K_n2<600 ))
pred_range = seq(0.2,0.75,0.01)
resp_n = predict(mod_1n,list(pred_range))
lines(pred_range, resp_n,col = 4,lw=3)
l_1n = length(reads2.5K_n2)
l_1t = length(reads2.5K_t2)
par(mfcol = c(1,1))
plot(GC2.5K[samp1],reads2.5K_n2[samp1],ylim = c(0,600),xlim = c(0.2,.75), cex = 0.5, pch=20)
mod_1n = lm(reads2.5K_n2~bs(GC2.5K,deg = 3,knots = c(seq(0.25,0.6,0.025),0.65)),subset = (reads2.5K_n2>50 & reads2.5K_n2<600 ))
pred_range = seq(0.2,0.75,0.01)
resp_n = predict(mod_1n,list(pred_range))
lines(GC2.5K, resp_n,col = 4,lw=3)
l_1n = length(reads2.5K_n2)
l_1t = length(reads2.5K_t2)
par(mfcol = c(1,1))
plot(GC2.5K[samp1],reads2.5K_n2[samp1],ylim = c(0,600),xlim = c(0.2,.75), cex = 0.5, pch=20)
mod_1n = lm(reads2.5K_n2~bs(GC2.5K,deg = 3,knots = c(seq(0.25,0.6,0.025),0.65)),subset = (reads2.5K_n2>50 & reads2.5K_n2<600 ))
pred_range = seq(0.2,0.75,0.01)
resp_n = predict(mod_1n,list(pred_range))
lines(GC2.5K[samp1], resp_n,col = 4,lw=3)
